describe("Ext.data.Session",function(){function J(P,O){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(P)},O)}var H;function M(P,O){if(Ext.isObject(P)){P=P.id;O=O.id}return P-O}var K,N;var A,F,L;var C,G;var B,E,D;beforeEach(function(){K={id:42,name:"Admins"};N={id:427,name:"Peons"};B={id:10,name:"Rufus"};E={id:20,name:"Bill"};D={id:30,name:"Ted"};A=[K,N];F=[N];L=[N];C=[B];G=[E,D,B]});function I(O,S,P,R){P=P||H;R=R||{};var Q=P.getRecord(O,S);R.id=R.id||S;J(R);return Q}beforeEach(function(){MockAjaxManager.addMethods()});afterEach(function(){MockAjaxManager.removeMethods();Ext.destroy(H);H=null});describe("record access",function(){var P,Q,O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");P=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name",{name:"addressId",reference:"Address",unique:true}],manyToMany:"Group"});Q=new Ext.data.Session();H=new Ext.data.Session()});afterEach(function(){Q.destroy();P=O=Q=null;Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});describe("adopt",function(){it("should cache the record into the session",function(){O=new P({id:1});H.adopt(O);expect(H.peekRecord("User",1)).toBe(O)});it("should put the session on the record",function(){O=new P({id:1});H.adopt(O);expect(O.session).toBe(H)});it("should not throw an error if a record already in the session is adopted",function(){O=I("User",1);expect(function(){H.adopt(O)}).not.toThrow()});describe("invalid conditions",function(){it("should not allow phantom records",function(){O=new P();expect(function(){H.adopt(O)}).toThrow()});it("should not allow a record attached to another session",function(){var S=new Ext.data.Session(),R=I("User",1,S);expect(function(){H.adopt(R)}).toThrow();S.destroy()});it("should raise an error if add a model the schema does not know about",function(){var R=new Ext.data.schema.Schema();Ext.define("spec.CustomModel",{extend:"Ext.data.Model",schema:R});O=new spec.CustomModel({id:1});expect(function(){H.adopt(O)}).toThrow()});it("should raise an error if adding an existing record",function(){O=I("User",1);expect(function(){H.adopt(new P({id:1}))}).toThrow()})})});describe("createRecord",function(){it("should accept the entity name",function(){O=H.createRecord("User",{name:"Foo"});expect(O.$className).toBe("spec.User");expect(O.get("name")).toBe("Foo")});it("should accept the entity class",function(){O=H.createRecord(spec.User,{name:"Foo"});expect(O.$className).toBe("spec.User");expect(O.get("name")).toBe("Foo")});it("should throw an exception with an unrecognized model name",function(){expect(function(){H.createRecord("Luser",{})}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){H.createRecord(R,{})}).toThrow()});it("should cache the record in the session",function(){O=H.createRecord("User",{});expect(H.getRecord("User",O.getId())).toBe(O)});it("should set the session on the instance",function(){O=H.createRecord("User",{});expect(O.session).toBe(H)});it("should throw an exception if the record exists in the session",function(){I("User",1);expect(function(){O=H.createRecord("User",{id:1}).toThrow()})});describe("with a parent",function(){beforeEach(function(){H.setParent(Q)});it("should not create the record in the parent session",function(){I("User",1);expect(Q.peekRecord("User",1)).toBeNull()});it("should raise an exception if the record exists in the parent",function(){I("User",1,Q);expect(function(){H.createRecord("User",{id:1})}).toThrow()})})});describe("getRecord",function(){it("should throw an exception with an unrecognized model name",function(){expect(function(){H.getRecord("Luser",1)}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){H.getRecord(R,1)}).toThrow()});describe("with no record",function(){it("should accept the entity name",function(){O=H.getRecord("User",1);expect(O.getId()).toBe(1);expect(O.$className).toBe("spec.User")});it("should accept the entity class",function(){O=H.getRecord(spec.User,1);expect(O.getId()).toBe(1);expect(O.$className).toBe("spec.User")});it("should create a new record and track it in the session",function(){O=H.getRecord("User",1);expect(H.peekRecord("User",1)).toBe(O)});it("should set the session on the record",function(){O=H.getRecord("User",1);expect(O.session).toBe(H)});describe("autoLoad",function(){it("should autoLoad by default",function(){var R=spyOn(spec.User.getProxy(),"read");H.getRecord("User",1);expect(R).toHaveBeenCalled()});it("should not autoLoad when passed: false",function(){var R=spyOn(spec.User.getProxy(),"read");H.getRecord("User",1,false);expect(R).not.toHaveBeenCalled()});it("should pass parameters to load",function(){var R=spyOn(spec.User.getProxy(),"read");H.getRecord("User",1,{params:{someId:1}});expect(R.mostRecentCall.args[0].getParams()).toEqual({someId:1})})});describe("with parent session",function(){beforeEach(function(){H.setParent(Q)});describe("record exists in the parent",function(){beforeEach(function(){O=I("User",1,Q,{name:"Foo"})});it("should return an existing record from the parent",function(){var R=H.getRecord("User",1);expect(R.get("name")).toBe("Foo");expect(R.$className).toBe("spec.User")});it("should return a copy, not the same instance",function(){var R=H.getRecord("User",1);expect(R).not.toBe(O)});it("should set the session to be the child session",function(){var R=H.getRecord("User",1);expect(R.session).toBe(H)});it("should not trigger a load",function(){var R=spyOn(spec.User.getProxy(),"read");H.getRecord("User",1);expect(R).not.toHaveBeenCalled()});it("should not update the parent record when the child changes",function(){var R=H.getRecord("User",1);R.set("name","Bar");expect(O.get("name")).toBe("Foo")});it("should not update the child record when the parent changes",function(){var R=H.getRecord("User",1);O.set("name","Bar");expect(R.get("name")).toBe("Foo")});it("should not copy the record if the parent is loading",function(){O=Q.getRecord("User",2);var R=H.getRecord("User",2);J({name:"Foo"});expect(O.get("name")).toBe("Foo");expect(R.isLoading()).toBe(true);expect(R.get("name")).toBeUndefined()})});describe("record does not exist in the parent",function(){it("should create an instance",function(){O=H.getRecord("User",1);expect(O.getId()).toBe(1);expect(O.$className).toBe("spec.User")});it("not push the instance into the parent",function(){H.getRecord("User",1);expect(Q.peekRecord("User",1)).toBeNull()})})})});describe("with an existing record",function(){beforeEach(function(){O=I("User",1)});it("should accept the entity name",function(){expect(H.getRecord("User",1)).toBe(O)});it("should accept the entity class",function(){expect(H.getRecord(spec.User,1)).toBe(O)});it("should return the existing record",function(){expect(H.getRecord("User",1)).toBe(O)});it("should not attempt to load the record",function(){var R=spyOn(spec.User.getProxy(),"read");H.getRecord("User",1);expect(R).not.toHaveBeenCalled()})})});describe("peekRecord",function(){beforeEach(function(){O=I("User",1)});it("should accept the entity name",function(){expect(H.peekRecord("User",1)).toBe(O)});it("should accept the entity class",function(){expect(H.peekRecord(spec.User,1)).toBe(O)});it("should throw an exception with an unrecognized model name",function(){expect(function(){H.peekRecord("Luser",1)}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){H.peekRecord(R,1)}).toThrow()});it("should return the model instance",function(){var R=H.peekRecord("User",1);expect(R.isModel).toBe(true);expect(R).toBe(O)});it("should return null if the record does not exist",function(){expect(H.peekRecord("User",12)).toBeNull()});describe("parent",function(){it("should not return a record from a parent without deep=true",function(){H.setParent(Q);I("User",2,Q);expect(H.peekRecord("User",2)).toBeNull()});it("should find a record in the parent session if we pass deep=true",function(){H.setParent(Q);O=I("User",2,Q);expect(H.peekRecord("User",2,true)).toBe(O)});it("should favour a record in the child",function(){H.setParent(Q);I("User",2,Q);O=H.getRecord("User",2);expect(H.peekRecord("User",2,true)).toBe(O)});it("should not consider a parent if we pass deep=true and there is no parent",function(){expect(H.peekRecord("User",1000,true)).toBeNull()})})});describe("associations",function(){describe("many to one",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});function R(V,T,U){U=U||{};U.id=V;U.userId=T;return I("Post",V,H,U)}function S(U,T){T=T||{};T.id=U;return I("User",U,H,T)}afterEach(function(){Ext.undefine("spec.Post")});describe("the one",function(){it("should use an existing record instance from the session",function(){var U=S(1),T=R(17,1);expect(T.getUser()).toBe(U)});it("should not trigger a load when the record instance exists",function(){var V=S(1),T=R(17,1),U=spyOn(spec.User.getProxy(),"read");T.getUser();expect(U).not.toHaveBeenCalled()});it("should request an instance it needs and put it in the session",function(){var T=R(17,1),U=T.getUser();J({id:1});expect(H.getRecord("User",1)).toBe(U)})});describe("the many",function(){var T;beforeEach(function(){T=S(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.posts();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.Post.getProxy(),"read");T.posts();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.posts();U.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);expect(U.getAt(0)).toBe(H.peekRecord("Post",101));expect(U.getAt(1)).toBe(H.peekRecord("Post",102));expect(U.getAt(2)).toBe(H.peekRecord("Post",103))});it("should set the complete flag on loading",function(){var U=T.posts();U.load();J([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should add items with a matching foreign key on creation, but not be complete",function(){var V=R(101,1),W=R(103,1),U=T.posts();expect(U.getCount()).toBe(2);expect(U.getAt(0)).toBe(V);expect(U.getAt(1)).toBe(W);expect(U.complete).toBe(false)});it("should respect the server order when loading with existing items",function(){var W=R(101,1),U=R(102,1),X=R(103,1),V=T.posts();V.load();J([{id:103,userId:1},{id:102,userId:1},{id:101,userId:1}]);expect(V.getAt(0)).toBe(X);expect(V.getAt(1)).toBe(U);expect(V.getAt(2)).toBe(W)});it("should add matching FK items to the end when loading",function(){var U=R(102,1),V=T.posts();V.load();J([{id:103,userId:1},{id:101,userId:1}]);expect(V.getAt(0)).toBe(H.peekRecord("Post",103));expect(V.getAt(1)).toBe(H.peekRecord("Post",101));expect(V.getAt(2)).toBe(H.peekRecord("Post",102))});it("should remove no-longer matching FK items when loading",function(){var U=R(102,1);U.set("userId",null);var V=T.posts();V.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);expect(V.getCount()).toBe(2);expect(V.getAt(0)).toBe(H.peekRecord("Post",101));expect(V.getAt(1)).toBe(H.peekRecord("Post",103))})})})});describe("one to one",function(){beforeEach(function(){Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]})});function R(U,T){T=T||{};T.id=U;return I("Address",U,H,T)}function S(V,T,U){U=U||{};U.id=V;U.addressId=T;return I("User",V,H,U)}afterEach(function(){Ext.undefine("spec.Address")});describe("the key holder",function(){it("should use an existing record instance from the session",function(){var T=R(1),U=S(17,1);expect(U.getAddress()).toBe(T)});it("should not trigger a load when the record instance exists",function(){var T=R(1),V=S(17,1),U=spyOn(spec.User.getProxy(),"read");V.getAddress();expect(U).not.toHaveBeenCalled()});it("should request an instance it needs and put it in the session",function(){var U=S(17,1),T=U.getAddress();J({id:1});expect(H.getRecord("Address",1)).toBe(T)})})});describe("many to many",function(){beforeEach(function(){Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"]})});function S(T){return I("User",T,H)}function R(T){return I("Group",T,H)}afterEach(function(){Ext.undefine("spec.Group")});describe("the left",function(){var T;beforeEach(function(){T=S(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.groups();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.Group.getProxy(),"read");T.groups();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.groups();U.load();J([{id:101},{id:102},{id:103}]);expect(U.getAt(0)).toBe(H.peekRecord("Group",101));expect(U.getAt(1)).toBe(H.peekRecord("Group",102));expect(U.getAt(2)).toBe(H.peekRecord("Group",103))});it("should set the complete flag on loading",function(){var U=T.groups();U.load();J([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should respect the load order when loading with existing items",function(){var V=R(102),U=T.groups();U.add(V);U.load();J([{id:103},{id:102},{id:101}]);expect(U.getAt(0)).toBe(H.peekRecord("Group",103));expect(U.getAt(1)).toBe(V);expect(U.getAt(2)).toBe(H.peekRecord("Group",101))});it("should add matching FK items to the end when loading",function(){var V=R(102),U=T.groups();U.add(V);U.load();J([{id:103},{id:101}]);expect(U.getAt(0)).toBe(H.peekRecord("Group",103));expect(U.getAt(1)).toBe(H.peekRecord("Group",101));expect(U.getAt(2)).toBe(V)})})});describe("the right",function(){var T;beforeEach(function(){T=R(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.users();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.User.getProxy(),"read");T.users();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.users();U.load();J([{id:101},{id:102},{id:103}]);expect(U.getAt(0)).toBe(H.peekRecord("User",101));expect(U.getAt(1)).toBe(H.peekRecord("User",102));expect(U.getAt(2)).toBe(H.peekRecord("User",103))});it("should set the complete flag on loading",function(){var U=T.users();U.load();J([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should respect the load order when loading with existing items",function(){var V=S(102),U=T.users();U.add(V);U.load();J([{id:103},{id:102},{id:101}]);expect(U.getAt(0)).toBe(H.peekRecord("User",103));expect(U.getAt(1)).toBe(V);expect(U.getAt(2)).toBe(H.peekRecord("User",101))});it("should add matching FK items to the end when loading",function(){var V=S(102),U=T.users();U.add(V);U.load();J([{id:103},{id:101}]);expect(U.getAt(0)).toBe(H.peekRecord("User",103));expect(U.getAt(1)).toBe(H.peekRecord("User",101));expect(U.getAt(2)).toBe(V)})})})})})});describe("getChanges",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");H=new Ext.data.Session();O=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age",{name:"addressId",reference:"Address",unique:true}],manyToMany:"#Group"});Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]});Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Address");Ext.undefine("spec.Post");Ext.undefine("spec.Group");Ext.data.Model.schema.clear(true);O=null});describe("basic operations",function(){describe("create",function(){it("should include a phantom record",function(){var P=H.createRecord("User",{name:"Foo",age:34});expect(H.getChanges()).toEqual({User:{C:[{id:P.getId(),name:"Foo",age:34}]}})});it("should include the updated record state",function(){var P=H.createRecord("User",{name:"Foo",age:34});P.set("name","Bar");P.set("age",5000);expect(H.getChanges()).toEqual({User:{C:[{id:P.getId(),name:"Bar",age:5000}]}})});it("should be able to create multiple records",function(){var P=H.createRecord("User"),Q=H.createRecord("User"),R=H.createRecord("User");expect(H.getChanges()).toEqual({User:{C:[{id:P.getId()},{id:Q.getId()},{id:R.getId()}]}})});it("should not include non-phantoms",function(){var P=I("User",1);expect(H.getChanges()).toBeNull()});it("should not include phantom records that are dropped",function(){var P=H.createRecord("User");P.drop();expect(H.getChanges()).toBeNull()})});describe("update",function(){it("should include the updated record",function(){var P=I("User",1);P.set("name","Foo");expect(H.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"}]}})});it("should include the most recently updated state",function(){var P=I("User",1);P.set("name","Foo");P.set("name","Bar");P.set("name","Baz");expect(H.getChanges()).toEqual({User:{U:[{id:1,name:"Baz"}]}})});it("should be able to update many records",function(){var P=I("User",1),Q=I("User",2),R=I("User",3);P.set("name","Foo");Q.set("name","Bar");R.set("name","Baz");expect(H.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"},{id:2,name:"Bar"},{id:3,name:"Baz"}]}})});it("should not include a non-dirty record",function(){var P=I("User",1);P.set("name","Foo");P.commit();expect(H.getChanges()).toBeNull()});it("should not include a dropped record",function(){var P=I("User",1);P.set("name","Foo");P.drop();expect(H.getChanges().User.U).toBeUndefined()});it("should not include changes to phantoms",function(){var P=H.createRecord("User");P.set("name","Foo");expect(H.getChanges().User.U).toBeUndefined()})});describe("drop",function(){it("should include dropped records",function(){var P=I("User",1);P.drop();expect(H.getChanges()).toEqual({User:{D:[1]}})});it("should drop multiple records",function(){var P=I("User",1),Q=I("User",2);user3=I("User",3);P.drop();Q.drop();user3.drop();expect(H.getChanges()).toEqual({User:{D:[1,2,3]}})});it("should not include phantom records",function(){var P=H.createRecord("User");P.drop();expect(H.getChanges()).toBeNull()})})});describe("associations",function(){describe("one to one",function(){var Q,P;beforeEach(function(){Q=I("User",1,H,{addressId:17});P=Q.getAddress();I("Address",17)});afterEach(function(){Q=P=null});it("should not include any changes when loading an association",function(){expect(H.getChanges()).toBeNull()});it("should not include extraneous records when changing the key",function(){Q.setAddress(3);expect(H.getChanges()).toEqual({User:{U:[{id:1,addressId:3}]}})});it("should read the non key holder when nulling out a reference",function(){Q.setAddress(null);expect(H.getChanges()).toEqual({User:{U:[{id:1,addressId:null}]}})})});describe("many to one",function(){var Q,P;beforeEach(function(){Q=I("User",1);P=Q.posts();P.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}])});afterEach(function(){Q=P=null});it("should not include any read records",function(){expect(H.getChanges()).toBeNull()});it("should push store removals as updates",function(){P.removeAt(0);expect(H.getChanges()).toEqual({Post:{U:[{id:101,userId:null}]}})});it("should push store adds as updates",function(){var R=I("Post",104);P.add(R);expect(H.getChanges()).toEqual({Post:{U:[{id:104,userId:1}]}})});it("should push store adds of phantoms as creates",function(){var R=H.createRecord("Post");P.add(R);expect(H.getChanges()).toEqual({Post:{C:[{id:R.getId(),userId:1}]}})})});describe("many to many",function(){describe("via store modifications",function(){var Q,P;beforeEach(function(){Q=I("User",1);P=Q.groups()});afterEach(function(){Q=P=null});describe("store not loaded",function(){it("should include local adds",function(){var R=I("Group",101);P.add(R);expect(H.getChanges()).toEqual({User:{groups:{C:{1:[101]}}}})});it("should include local phantom adds and a create",function(){var R=H.createRecord("Group"),S=R.getId();P.add(R);expect(H.getChanges()).toEqual({User:{groups:{C:{1:[S]}}},Group:{C:[{id:R.getId()}]}})});it("should ignore adds & cancelling removes",function(){var R=I("Group",101);P.add(R);P.removeAt(0);expect(H.getChanges()).toBeNull()})});describe("store loaded",function(){beforeEach(function(){P.load();J([{id:101},{id:102},{id:103}])});it("should not include any records loaded into the store",function(){expect(H.getChanges()).toBeNull()});it("should include a local add to existing records",function(){var R=I("Group",104);P.add(R);expect(H.getChanges()).toEqual({User:{groups:{C:{1:[104]}}}})});it("should include local phantom adds and a create",function(){var R=H.createRecord("Group"),S=R.getId();P.add(R);expect(H.getChanges()).toEqual({User:{groups:{C:{1:[S]}}},Group:{C:[{id:R.getId()}]}})});it("should ignore adds & cancelling removes",function(){var R=I("Group",104);P.add(R);P.remove(R);expect(H.getChanges()).toBeNull()});it("should drop records removed from the store",function(){P.removeAt(0);expect(H.getChanges()).toEqual({User:{groups:{D:{1:[101]}}}})})})});describe("via updates",function(){it("should process creates without records",function(){H.update({User:{groups:{C:{1:[101,102]}}}});expect(H.getChanges()).toEqual({User:{groups:{C:{1:[101,102]}}}})});it("should process drops without records",function(){H.update({User:{groups:{D:{1:[103,104]}}}});expect(H.getChanges()).toEqual({User:{groups:{D:{1:[103,104]}}}})})})})})});describe("update",function(){beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");H=new Ext.data.Session()});afterEach(function(){rec=null;Ext.data.Model.schema.clear(true)});describe("basic operations",function(){var P;function O(Q,S){var R={User:{}};R.User[Q]=S;return R}beforeEach(function(){P=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age"]})});afterEach(function(){Ext.undefine("spec.User");P=null});it("should throw an exception for an unrecognized entity",function(){expect(function(){H.update({Luser:{}})}).toThrow()});describe("read",function(){it("should add the record to the session",function(){H.update(O("R",[{id:17}]));expect(H.peekRecord("User",17)).not.toBeNull()});it("should have the data on the record",function(){H.update(O("R",[{id:17,name:"Foo",age:32}]));var Q=H.getRecord("User",17);expect(Q.get("name")).toBe("Foo");expect(Q.get("age")).toBe(32)});it("should not be dirty",function(){H.update(O("R",[{id:17,name:"Foo",age:32}]));var Q=H.getRecord("User",17);expect(Q.dirty).toBe(false)});it("should not be phantom even if we don't have an id",function(){H.update(O("R",[{name:"Foo",age:32}]));var Q=H.getRecord("User","User-1");expect(Q.phantom).toBe(false)});it("should be able to read multiple records",function(){H.update(O("R",[{id:1,name:"Foo"},{id:2,name:"Bar"},{id:3,name:"Baz"}]));expect(H.peekRecord("User",1)).not.toBeNull();expect(H.peekRecord("User",2)).not.toBeNull();expect(H.peekRecord("User",3)).not.toBeNull()});it("should throw an exception if the record is in the session",function(){I("User",1);expect(function(){H.update(O("R",[{id:1}]))}).toThrow()})});describe("create",function(){it("should add the record to the session",function(){H.update(O("C",[{id:17}]));expect(H.peekRecord("User",17)).not.toBeNull()});it("should have the data on the record",function(){H.update(O("C",[{id:17,name:"Foo",age:32}]));var Q=H.getRecord("User",17);expect(Q.get("name")).toBe("Foo");expect(Q.get("age")).toBe(32)});it("should be a phantom",function(){H.update(O("C",[{name:"Foo",age:32}]));var Q=H.getRecord("User","User-1");expect(Q.phantom).toBe(true)});it("should be able to create multiple records",function(){H.update(O("C",[{name:"Foo"},{name:"Bar"},{name:"Baz"}]));expect(H.peekRecord("User","User-1")).not.toBeNull();expect(H.peekRecord("User","User-2")).not.toBeNull();expect(H.peekRecord("User","User-3")).not.toBeNull()});it("should throw an exception if the record is in the session",function(){I("User",17);expect(function(){H.update(O("C",[{id:17}]))}).toThrow()})});describe("drop",function(){it("should drop the record",function(){var Q=I("User",100);H.update(O("D",[100]));expect(Q.dropped).toBe(true)});it("should be able to drop multiple records",function(){var Q=I("User",100),R=I("User",200),S=I("User",300);H.update(O("D",[100,200,300]));expect(Q.dropped).toBe(true);expect(R.dropped).toBe(true);expect(S.dropped).toBe(true)});it("should throw an exception if the record does not exist",function(){expect(function(){H.update(O("D",[100]))}).toThrow()})});describe("update",function(){it("should update the record data",function(){var Q=H.createRecord("User",{id:100,name:"Foo"});H.update(O("U",[{id:100,name:"Bar"}]));expect(Q.get("name")).toBe("Bar")});it("should not commit the record",function(){var Q=H.createRecord("User",{id:100,name:"Foo",age:10});H.update(O("U",[{id:100,name:"Bar",age:11}]));expect(Q.dirty).toBe(true);expect(Q.isModified("name")).toBe(true);expect(Q.isModified("age")).toBe(true)});it("should not be dirty if the data does not change",function(){var Q=H.createRecord("User",{id:100,name:"Foo",age:23});H.update(O("U",[{id:100,name:"Foo",age:23}]));expect(Q.dirty).toBe(false)});it("should handle multiple updates",function(){var S=H.createRecord("User",{id:101,name:"Foo"});var R=H.createRecord("User",{id:102,name:"Bar"});var Q=H.createRecord("User",{id:103,name:"Baz"});H.update(O("U",[{id:101,name:"A"},{id:102,name:"B"},{id:103,name:"C"}]));expect(S.get("name")).toBe("A");expect(R.get("name")).toBe("B");expect(Q.get("name")).toBe("C")});it("should handle object syntax",function(){var S=H.createRecord("User",{id:101,name:"Foo"});var R=H.createRecord("User",{id:102,name:"Bar"});var Q=H.createRecord("User",{id:103,name:"Baz"});H.update(O("U",{101:{name:"A"},102:{name:"B"},103:{name:"C"}}));expect(S.get("name")).toBe("A");expect(R.get("name")).toBe("B");expect(Q.get("name")).toBe("C")});it("should throw an exception if the record does not exist in the store",function(){expect(function(){H.update(O("U",[{id:100,name:"Bar"}]))}).toThrow()});it("should throw an exception if the record is dropped",function(){var Q=I("User",1);Q.drop();expect(function(){H.update(O("U",[{id:100,name:"Bar"}]))}).toThrow()})});describe("associations",function(){var R,Q;beforeEach(function(){R=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"userId",reference:"User"}]});Q=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["id","name"],manyToMany:"User"})});afterEach(function(){R=Q=null;Ext.undefine("spec.Post");Ext.undefine("spec.Group")});describe("many to one",function(){it("should process any CRUD operations before associations",function(){H.update({User:{R:[{id:1}],posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}});var S=H.getRecord("User",1);expect(S.posts().indexOfId(101)).toBe(0)});describe("without an entity CRUD block",function(){it("should throw an exception if the owner model does not exist",function(){I("Post",101);expect(function(){H.update({User:{posts:{R:{1:[101]}}}})}).toThrow()});it("should throw an exception if the child model does not exist",function(){I("User",1);expect(function(){H.update({User:{posts:{R:{1:[101]}}}})}).toThrow()})});describe("with an entity CRUD block",function(){it("should throw an exception if the owner model does not exist and wasn't read",function(){expect(function(){H.update({User:{posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}})}).toThrow()});it("should throw an exception if the child model does not exist and wasn't read",function(){expect(function(){H.update({User:{R:[{id:1}],posts:{R:{1:[101]}}}})}).toThrow()})});describe("with the store not created",function(){it("should create the store with data",function(){var T=I("User",1);H.update({User:{posts:{R:{1:[101,102,103]}}},Post:{R:[{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]}});var S=T.posts();expect(S.getCount()).toBe(3);expect(S.getAt(0)).toBe(H.peekRecord("Post",101));expect(S.getAt(1)).toBe(H.peekRecord("Post",102));expect(S.getAt(2)).toBe(H.peekRecord("Post",103))});it("should create the store and not trigger a load, should set loadCount & complete",function(){var U=I("User",1),S=spyOn(R.getProxy(),"read");H.update({User:{posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}});var T=U.posts();expect(T.getCount()).toBe(1);expect(T.loadCount).toBe(1);expect(T.complete).toBe(true);expect(S).not.toHaveBeenCalled()});it("should include local records with matching FK",function(){var U=I("User",1),T=I("Post",101);T.set("userId",1);H.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});var S=U.posts();expect(S.getCount()).toBe(2)});it("should exclude local records where the FK does not match",function(){var U=I("User",1),T=I("Post",101);H.update({User:{posts:{R:{1:[101]}}}});var S=U.posts();expect(S.getCount()).toBe(0)})});describe("with the store created",function(){it("should fill an empty store",function(){var T=I("User",1),S=T.posts();H.update({User:{posts:{R:{1:[101,102,103]}}},Post:{R:[{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]}});expect(S.getCount()).toBe(3);expect(S.getAt(0)).toBe(H.peekRecord("Post",101));expect(S.getAt(1)).toBe(H.peekRecord("Post",102));expect(S.getAt(2)).toBe(H.peekRecord("Post",103));expect(S.complete).toBe(true)});describe("store not loaded",function(){it("should include locally added records",function(){var U=I("User",1),T=I("Post",101),S=U.posts();S.add(T);H.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(S.getCount()).toBe(2);expect(S.indexOf(T)).toBe(1)});it("should include records with local foreign key modifications",function(){var U=I("User",1),T=I("Post",101),S=U.posts();T.set("userId",1);H.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(S.getCount()).toBe(2);expect(S.indexOf(H.peekRecord("Post",102))).toBe(0);expect(S.indexOf(T)).toBe(1)});it("should exclude locally removed records",function(){var V=I("User",1),U=I("Post",101,H,{userId:1}),S=I("Post",102,H,{userId:1}),T=V.posts();T.removeAt(0);H.update({User:{posts:{R:{1:[101,102]}}}});expect(T.getCount()).toBe(1);expect(T.indexOf(S)).toBe(0);expect(T.indexOf(U)).toBe(-1)});it("should exclude records with local foreign key modifications",function(){var V=I("User",1),U=I("Post",101,H,{userId:1}),S=I("Post",102,H,{userId:1}),T=V.posts();U.set("userId",null);H.update({User:{posts:{R:{1:[101,102]}}}});expect(T.getCount()).toBe(1);expect(T.indexOf(S)).toBe(0);expect(T.indexOf(U)).toBe(-1)})});describe("store already loaded",function(){it("should include added items",function(){var U=I("User",1),T=I("Post",101),S=U.posts();S.load();J([]);S.add(T);H.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(S.getCount()).toBe(2);expect(S.getAt(0)).toBe(H.peekRecord("Post",102));expect(S.getAt(1)).toBe(T)});it("should exclude removed items",function(){var S=I("User",1);posts=S.posts();posts.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);posts.removeAt(0);H.update({User:{posts:{R:{1:[101,102,103]}}}});expect(posts.getCount()).toBe(2);expect(posts.getAt(0)).toBe(H.peekRecord("Post",102));expect(posts.getAt(1)).toBe(H.peekRecord("Post",103))})})})});describe("many to many",function(){describe("read",function(){it("should read CRUD records before processing",function(){H.update({User:{R:[{id:1}],groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});var T=H.getRecord("User",1),S=T.groups();expect(S.getCount()).toBe(2);expect(S.getAt(0)).toBe(H.peekRecord("Group",101));expect(S.getAt(1)).toBe(H.peekRecord("Group",102))});it("should require the child records being read to be present",function(){expect(function(){H.update({User:{R:[{id:1}],groups:{R:{1:[101,102]}}}})}).toThrow()});it("should require the parent record being read to be present",function(){expect(function(){H.update({User:{groups:{R:{1:[101]}}},Post:{R:[{id:101}]}})}).toThrow()});describe("with the store not created",function(){it("should create a store with the items",function(){var T=I("User",1);H.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});var S=T.groups();expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(H.peekRecord("Group",101))});it("should not trigger a load",function(){var T=I("User",1),S=spyOn(Q.getProxy(),"read");H.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(S).not.toHaveBeenCalled()});it("should set the complete flag",function(){var S=I("User",1);H.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(S.groups().complete).toBe(true)});it("should include locally created records",function(){var T=I("User",1);H.update({User:{groups:{C:{1:[101]}}}});H.update({User:{groups:{R:{1:[102]}}},Group:{R:[{id:102}]}});I("Group",101);var S=T.groups();expect(S.getCount()).toBe(2);expect(S.indexOfId(102)).toBe(0);expect(S.indexOfId(101)).toBe(1)});it("should exclude locally dropped records",function(){var T=I("User",1);H.update({User:{groups:{D:{1:[101]}}}});H.update({User:{groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});var S=T.groups();expect(S.getCount()).toBe(1);expect(S.indexOfId(102)).toBe(0)})});describe("with the store created",function(){describe("store not loaded",function(){it("should fill an empty store",function(){var T=I("User",1),S=T.groups();H.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(S.getCount()).toBe(1);expect(S.first()).toBe(H.peekRecord("Group",101))});it("should include local store adds",function(){var U=I("User",1),T=I("Group",101),S=U.groups();S.add(T);H.update({User:{groups:{R:{1:[102]}}},Group:{R:[{id:102}]}});expect(S.getCount()).toBe(2);expect(S.getAt(0)).toBe(H.peekRecord("Group",102));expect(S.getAt(1)).toBe(T)});it("should exclude local drops",function(){var T=I("User",1),S=T.groups();H.update({User:{groups:{D:{1:[101]}}}});H.update({User:{groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(H.peekRecord("Group",102))})});describe("store already loaded",function(){it("should include local store adds",function(){var U=I("User",1),S=U.groups(),T=I("Group",104);S.load();J([{id:101},{id:102},{id:103}]);S.add(T);H.update({User:{groups:{R:{1:[101,102,103]}}}});expect(S.getCount()).toBe(4);expect(S.indexOf(T)).toBe(3)});it("should exclude local store removes",function(){var T=I("User",1),S=T.groups();S.load();J([{id:101},{id:102}]);S.removeAt(0);H.update({User:{groups:{R:{1:[101,102]}}}});expect(S.getCount()).toBe(1)})})})});describe("create",function(){describe("with the store not created",function(){describe("with the record created",function(){it("should have the record present in the store when the store is created",function(){var U=I("User",1),T=I("Group",101);H.update({User:{groups:{C:{1:[101]}}}});var S=U.groups();expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(T)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var U=I("User",1);H.update({User:{groups:{C:{1:[101]}}}});var S=U.groups();expect(S.getCount()).toBe(0);var T=I("Group",101);expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(T)})})});describe("with the store created",function(){describe("store not loaded",function(){describe("with the record created",function(){it("should add the record to the store",function(){var U=I("User",1),T=I("Group",101),S=U.groups();H.update({User:{groups:{C:{1:[101]}}}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(T)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var U=I("User",1),S=U.groups();H.update({User:{groups:{C:{1:[101]}}}});expect(S.getCount()).toBe(0);var T=I("Group",101);expect(S.getAt(0)).toBe(T)})})});describe("store already loaded",function(){describe("with the record created",function(){it("should add the record to the store",function(){var U=I("User",1),T=U.groups(),S=I("Group",103);T.load();J([{id:101},{id:102}]);expect(T.getCount()).toBe(2);H.update({User:{groups:{C:{1:[103]}}}});expect(T.getCount()).toBe(3);expect(T.getAt(2)).toBe(S)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var U=I("User",1),T=U.groups();T.load();J([{id:101},{id:102}]);H.update({User:{groups:{C:{1:[103]}}}});expect(T.getCount()).toBe(2);var S=I("Group",103);expect(T.getCount()).toBe(3);expect(T.getAt(2)).toBe(S)})})})})});describe("drop",function(){describe("with the store not created",function(){it("should exclude the record when it is loaded",function(){var T=I("User",1);H.update({User:{groups:{D:{1:[101]}}}});var S=T.groups();S.load();J([{id:101},{id:102}]);expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(H.peekRecord("Group",102))})});describe("with the store created",function(){describe("store not loaded",function(){it("should exclude the record when it is loaded",function(){var T=I("User",1),S=T.groups();H.update({User:{groups:{D:{1:[101]}}}});S.load();J([{id:101},{id:102}]);expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(H.peekRecord("Group",102))})});describe("store already loaded",function(){it("should exclude the record from the store",function(){var T=I("User",1),S=T.groups();S.load();J([{id:101},{id:102}]);H.update({User:{groups:{D:{1:[101]}}}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(H.peekRecord("Group",102))})})})})})})})});describe("spawn",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"]})});afterEach(function(){Ext.destroy(O);O=null;Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});it("should set the schema from the parent",function(){var P=new Ext.data.schema.Schema();O=new Ext.data.Session({schema:P});H=O.spawn();expect(H.getSchema()).toBe(P)});it("should set the parent reference",function(){O=new Ext.data.Session();H=O.spawn();expect(H.getParent()).toBe(O)});describe("stores",function(){it("should use the data from parent records if they exist",function(){O=new Ext.data.Session();var Q=I("User",1,O);Q.set("name","Foo");H=O.spawn();var P=new Ext.data.Store({model:spec.User,session:H,proxy:{type:"ajax",url:"fakeUrl"}});P.load();J([{id:1,name:"Bar"}]);expect(H.peekRecord("User",1).get("name")).toBe("Foo")})})});describe("updating from child to parent sessions",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age"]});H=new Ext.data.Session()});afterEach(function(){Ext.undefine("spec.User");Ext.data.Model.schema.clear(true);Ext.destroy(O);O=null});it("should handle when there are no changes",function(){O=H.spawn();expect(O.getChangesForParent()).toBeNull();O.save();expect(H.getChanges()).toBeNull()});describe("create",function(){it("should push up creates to the parent",function(){O=H.spawn();rec=O.createRecord("User",{name:"Foo"});O.save();expect(H.getChanges()).toEqual({User:{C:[{id:rec.getId(),name:"Foo"}]}})})});describe("update",function(){it("should reflect update changes in the parent",function(){I("User",1);O=H.spawn();O.getRecord("User",1).set("name","Foo");O.save();expect(H.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"}]}})});it("should use a record that is a phantom in the parent as an update from the child",function(){var P=H.createRecord("User",{name:"Foo"}),Q=P.getId();O=H.spawn();O.getRecord("User",Q).set("name","Bar");O.save();expect(H.getChanges()).toEqual({User:{C:[{id:Q,name:"Bar"}]}})})});describe("drop",function(){it("should propagate a drop to the parent",function(){I("User",1);O=H.spawn();O.getRecord("User",1).drop();O.save();expect(H.getChanges()).toEqual({User:{D:[1]}})});it("should propagate a drop of a parent phantom, meaning we have no changes",function(){var P=H.createRecord("User"),Q=P.getId();O=H.spawn();O.getRecord("User",Q).drop();O.save();expect(H.getChanges()).toBeNull()})});describe("associations",function(){describe("many to one",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.Post")});describe("store loaded in the parent",function(){var Q,P;beforeEach(function(){Q=I("User",1);P=Q.posts();P.load();J([{id:101,userId:1},{id:102,userId:1}]);O=H.spawn();P=O.getRecord("User",1).posts()});afterEach(function(){Q=P=null});it("should push up a store removal as an update to the FK",function(){P.removeAt(0);O.save();expect(H.getChanges()).toEqual({Post:{U:[{userId:null,id:101}]}});expect(H.peekRecord("Post",101).dirty).toBe(true)});it("should push up a drop",function(){P.first().drop();O.save();expect(H.getChanges()).toEqual({Post:{D:[101]}});expect(H.peekRecord("Post",101).dropped).toBe(true)});it("should push a new phantom record as a creation",function(){var R=P.add({})[0].getId();O.save();expect(H.getChanges()).toEqual({Post:{C:[{id:R,userId:1}]}});expect(H.peekRecord("Post",R).phantom).toBe(true)});it("should push an added record as an update to the FK",function(){var R=I("Post",105,O);P.add(R);O.save();expect(H.getChanges()).toEqual({Post:{U:[{id:105,userId:1}]}});expect(H.peekRecord("Post",105).dirty).toBe(true)})});describe("store not loaded in the parent",function(){var R,Q,P;beforeEach(function(){R=I("User",1);O=H.spawn();P=O.getRecord("User",1);Q=P.posts()});afterEach(function(){users=Q=P=null});it("should read & update for a foreign key change",function(){Q.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);Q.removeAt(1);O.save();expect(H.getChanges()).toEqual({Post:{U:[{id:102,userId:null}]}});expect(H.peekRecord("Post",102).dirty).toBe(true)});it("should read and update for a drop",function(){Q.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);Q.getAt(1).drop();O.save();expect(H.getChanges()).toEqual({Post:{D:[102]}});expect(H.peekRecord("Post",102).dropped).toBe(true)});it("should push up phantom records as creates",function(){var S=Q.add({content:"Foo"})[0].getId();O.save();expect(H.getChanges()).toEqual({Post:{C:[{id:S,userId:1,content:"Foo"}]}});expect(H.peekRecord("Post",S).phantom).toBe(true)});it("should have no changes if the store is loaded",function(){Q.load();J([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);O.save();expect(H.getChanges()).toBeNull()})})});describe("many to many",function(){var P,R,Q,S;beforeEach(function(){Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"],manyToMany:"User"})});afterEach(function(){Ext.undefine("spec.Group");P=R=Q=S});describe("store loaded in the parent",function(){beforeEach(function(){P=I("Group",1);R=P.users();R.load();J([{id:101},{id:102},{id:103}]);O=H.spawn();Q=O.getRecord("Group",1);S=Q.users()});it("should copy the store from the parent",function(){expect(S.getCount()).toBe(3)});it("should add an existing record to the parent collection",function(){var T=I("User",104);S.add(O.getRecord("User",104));O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});expect(R.getCount()).toBe(4);expect(R.getAt(3)).toBe(T)});it("should have a pending add in the parent, not read the record up",function(){var T=I("User",104,O);S.add(T);O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});expect(H.peekRecord("User",104)).toBeNull();expect(R.getCount()).toBe(3);T=I("User",104);expect(R.getCount()).toBe(4);expect(R.indexOf(T)).toBe(3)});it("should push up a removal",function(){S.removeAt(0);O.save();expect(H.getChanges()).toEqual({Group:{users:{D:{1:[101]}}}});expect(R.getCount()).toBe(2)})});describe("store not loaded, created in the parent",function(){var T,U;beforeEach(function(){P=I("Group",1);R=P.users();T=I("User",101);U=I("User",102);R.add(T,U);O=H.spawn();Q=O.getRecord("Group",1);S=Q.users()});afterEach(function(){T=U=null});it("should copy the store from the parent",function(){expect(S.getCount()).toBe(2)});it("should add an existing record to the parent collection",function(){var V=I("User",104);S.add(O.getRecord("User",104));O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});expect(R.getCount()).toBe(3);expect(R.getAt(2)).toBe(V)});it("should have a pending add in the parent, not read the record up",function(){var V=I("User",104,O);S.add(V);O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});expect(R.getCount()).toBe(2);V=I("User",104);expect(R.getCount()).toBe(3);expect(R.indexOf(V)).toBe(2)});it("should push up a removal",function(){S.removeAt(0);O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[102]}}}});expect(R.getCount()).toBe(1)})});describe("store loaded in the child",function(){beforeEach(function(){P=I("Group",1);O=H.spawn();Q=O.getRecord("Group",1);S=Q.users();S.load();J([{id:101},{id:102},{id:103}])});it("should add an existing record to the parent collection",function(){var T=I("User",104);S.add(O.getRecord("User",104));O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});R=P.users();expect(R.getCount()).toBe(1);expect(R.getAt(0)).toBe(T)});it("should have a pending add in the parent, not read the record up",function(){var T=I("User",104,O);S.add(T);O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});R=P.users();expect(R.getCount()).toBe(0);T=I("User",104);expect(R.getCount()).toBe(1);expect(R.indexOf(T)).toBe(0)});it("should have a pending removal",function(){S.removeAt(0);O.save();expect(H.getChanges()).toEqual({Group:{users:{D:{1:[101]}}}});R=P.users();expect(R.getCount()).toBe(0);R.load();J([{id:101},{id:102},{id:103}]);expect(R.getCount()).toBe(2)})});describe("store not loaded, created in the child",function(){beforeEach(function(){P=I("Group",1);O=H.spawn();Q=O.getRecord("Group",1);S=Q.users();user1=I("User",101,O);user2=I("User",102,O);S.add(user1,user2)});afterEach(function(){user1=user2=null});it("should add an existing record to the parent collection",function(){var T=I("User",104);S.add(O.getRecord("User",104));O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});R=P.users();expect(R.getCount()).toBe(1);expect(R.getAt(0)).toBe(T)});it("should have a pending add in the parent, not read the record up",function(){O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[101,102]}}}});R=P.users();expect(R.getCount()).toBe(0);user1=I("User",101);user2=I("User",102);expect(R.getCount()).toBe(2);expect(R.indexOf(user1)).toBe(0);expect(R.indexOf(user2)).toBe(1)})});describe("empty parent",function(){it("should not push up the owning record if it was loaded in the child",function(){O=H.spawn();var T=I("Group",1,O),U=H.createRecord("User");T.users().add(U);O.save();expect(H.peekRecord("Group",1)).toBeNull()});it("should allow a create",function(){O=H.spawn();var T=I("Group",1,O),U=I("User",101,O);T.users().add(U);O.save();expect(H.getChanges()).toEqual({Group:{users:{C:{1:[101]}}}})});it("should establish a relationship when both parties load",function(){O=H.spawn();var T=I("Group",1,O),U=I("User",101,O);T.users().add(U);O.save();T=I("Group",1);U=I("User",101);expect(U.groups().indexOf(T)).toBe(0)})})})})});describe("Provisional identifiers",function(){function O(Q,R,P){describe("Schema with "+Q,function(){var S,T;beforeEach(function(){R.setNamespace("spec");S=Ext.define("spec.Base",{extend:Ext.data.Model,schema:R,fields:["id","name","key"]});T=Ext.define("spec.Derived",{extend:S});H=new Ext.data.Session({schema:S.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");S.schema.clear(true);S=T=null});describe("record creation",function(){it("should isolate id generation to the session",function(){var V=new S();var U=H.createRecord("Base",{name:"Don"});expect(V).not.toBe(U);expect(U.id).toBe(V.id)});it("should track all created records",function(){var V=H.createRecord("Base",{name:"Don"});expect(V.id).toBe(P["B-1"]);var U=H.createRecord("Derived",{name:"Evan"});expect(U.id).toBe(P["D-1"]);var W=H.getChanges();expect(W).toEqual({Base:{C:[{id:V.id,name:"Don"}]},Derived:{C:[{id:U.id,name:"Evan"}]}})})})})}O("default identities",Ext.data.Model.schema,{"B-1":"Base-1","D-1":"Derived-1"});O("negative identities",new Ext.data.schema.Schema({defaultIdentifier:"negative"}),{"B-1":-1,"D-1":-1});O("sequential identities",new Ext.data.schema.Schema({defaultIdentifier:"sequential"}),{"B-1":1,"D-1":1})});describe("Random UUID's",function(){var O,P;var Q;beforeEach(function(){if(!Q){Q=new Ext.data.schema.Schema({defaultIdentifier:"uuid"})}Q.setNamespace("spec");O=Ext.define("spec.Base",{extend:Ext.data.Model,schema:Q,fields:["id","name","key"]});H=new Ext.data.Session({schema:O.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");O.schema.clear(true);O=P=null});describe("record creation",function(){it("should copy identifier reference into the session",function(){var U=new O();var R=H.createRecord("Base",{name:"Don"});expect(U).not.toBe(R);expect(R.id).not.toBe(U.id);var T=H.getSchema().getDefaultIdentifier();var S=H.getIdentifier(O);expect(S).toBe(O.identifier);expect(S).toBe(T);expect(S).toBe(Ext.data.identifier.Uuid.Global)})})});describe("Sequential UUID's",function(){var O,P;var Q;beforeEach(function(){if(!Q){Q=new Ext.data.schema.Schema({defaultIdentifier:{type:"uuid",version:1,timestamp:233811181,salt:3203395597,clockSeq:2989}})}Q.setNamespace("spec");O=Ext.define("spec.Base",{extend:Ext.data.Model,schema:Q,fields:["id","name","key"]});H=new Ext.data.Session({schema:O.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");O.schema.clear(true);O=P=null});describe("record creation",function(){it("should copy identifier reference into the session",function(){var T=new O();var R=H.createRecord("Base",{name:"Don"});expect(T.id).toBe("0defaced-0000-1000-8bad-0100beeff00d");expect(R.id).toBe("0defacee-0000-1000-8bad-0100beeff00d");var U=H.getSchema().getDefaultIdentifier();var S=H.getIdentifier(O);expect(S).toBe(O.identifier);expect(S).toBe(U);expect(S).not.toBe(Ext.data.identifier.Uuid.Global)})})});describe("Many-to-many associations",function(){var P,O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");P=Ext.define("spec.User",{extend:Ext.data.Model,fields:["name","key"],manyToMany:"#Group"});O=Ext.define("spec.Group",{extend:Ext.data.Model,fields:["name","key"]});H=new Ext.data.Session({schema:P.schema})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Group");P.schema.clear(true);P=O=null});describe("loading a many-to-many",function(){it("should load groups for a user",function(){var R=H.getRecord("User",B.id,false).groups();R.load();J(A);expect(R.isStore).toBe(true);expect(R.getCount()).toBe(2);expect(R.getById(K.id)).toBeTruthy();expect(R.getById(N.id)).toBeTruthy();var Q=H.matrices.UserGroups;expect(Q.left.slices[10].members[42]).toEqual([10,42,0]);expect(Q.left.slices[10].members[427]).toEqual([10,427,0]);expect(Q.right.slices[42].members[10]).toEqual([10,42,0]);expect(Q.right.slices[427].members[10]).toEqual([10,427,0])});it("should load both sides of a matrix",function(){var Q=H.getRecord("User",B.id,false).groups(),U=H.getRecord("Group",K.id,false).users(),S=H.getRecord("Group",N.id,false).users();Q.load();S.load();U.load();J(A,1);J(G,2);J(C,3);expect(Q.isStore).toBe(true);expect(Q.getCount()).toBe(2);expect(Q.getById(K.id)).toBeTruthy();expect(Q.getById(N.id)).toBeTruthy();var T,R;expect(U.isStore).toBe(true);expect(U.getCount()).toBe(1);expect(T=U.getById(B.id)).toBeTruthy();expect(S.isStore).toBe(true);expect(S.getCount()).toBe(3);expect(S.getById(E.id)).toBeTruthy();expect(S.getById(D.id)).toBeTruthy();expect(R=S.getById(B.id)).toBeTruthy();expect(T).toBe(R)});it("should allow editing on both sides of a matrix",function(){var Q=H.getRecord("User",E.id,false).groups(),U=H.getRecord("User",B.id,false).groups(),W=H.getRecord("Group",K.id,false).users(),S=H.getRecord("Group",N.id,false).users();U.load();Q.load();S.load();W.load();J(A,1);J(F,2);J(G,3);J(C,4);expect(U.getCount()).toBe(2);expect(U.getById(K.id)).toBeTruthy();var V=W.getById(B.id);W.remove(V);expect(U.getCount()).toBe(1);expect(U.getById(K.id)).toBe(null);expect(Q.getCount()).toBe(1);expect(Q.getById(K.id)).toBe(null);var R=S.getById(E.id);W.add(R);expect(Q.getCount()).toBe(2);expect(Q.getById(K.id)).toBeTruthy();var T=H.getChanges();expect(T).toEqual({User:{groups:{C:{20:[42]},D:{10:[42]}}}})})})});describe("transactions",function(){var W,T,V,O,U,S;var P,Q,R;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");P=[{id:1,name:"parent1",code:"abc",foo:42},{id:2,name:"parent2",code:"def",foo:427}];Q=[{id:10,name:"child1",parentId:1},{id:20,name:"child2",parentId:2}];R=[{id:100,name:"grand1",childId:10},{id:200,name:"grand2",childId:20}];W=Ext.define("spec.Base",{extend:Ext.data.Model});S=Ext.define("spec.User",{extend:Ext.data.Model,fields:["name","key"],manyToMany:"#Group"});U=Ext.define("spec.Group",{extend:Ext.data.Model,fields:["name","key"]});T=Ext.define("spec.Parent",{extend:W,identifier:{type:"negative"},fields:["name","code",{name:"foo",critical:true}]});V=Ext.define("spec.Child",{extend:W,identifier:{type:"negative",seed:-10},fields:["name",{name:"parentId",reference:"Parent"}]});O=Ext.define("spec.GrandChild",{extend:W,identifier:{type:"negative",seed:-100},clientIdProperty:"cid",fields:["name",{name:"childId",reference:"Child"}]});H=new Ext.data.Session({schema:W.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Parent");Ext.undefine("spec.Child");Ext.undefine("spec.GrandChild");Ext.undefine("spec.Group");Ext.undefine("spec.User");Ext.data.Model.schema.clear(true);H=null;W=T=V=O=U=S=null});describe("complex transaction",function(){var X;beforeEach(function(){X={parentRecs:[],childRecs:[],grandChildRecs:[]};Ext.each([0,1],function(Y){X.grandChildRecs.push(H.createRecord("GrandChild",R[Y]));X.childRecs.push(H.createRecord("Child",Q[Y]));X.parentRecs.push(H.createRecord("Parent",P[Y]))});X.parentRecs[0].set("code","xyz");X.childRecs[0].set("name","child1a");X.grandChildRecs[0].set("name","grand1a");X.parentRecs[1].drop();X.childRecs[1].drop();X.grandChildRecs[1].drop();X.newParent=H.createRecord("Parent",{name:"newParent",foo:-42});X.newChild=H.createRecord("Child",{name:"newChild"});X.newGrandChild=H.createRecord("GrandChild");X.newChild.setParent(X.newParent);X.newGrandChild.setChild(X.newChild)});afterEach(function(){X=null});it("should describe the transaction via getChanges",function(){var Y=H.getChanges();expect(Y).toEqual({Parent:{C:[{id:-1,name:"newParent",foo:-42}],U:[{id:1,code:"xyz",foo:42}],D:[2]},Child:{C:[{id:-10,name:"newChild",parentId:-1}],U:[{id:10,name:"child1a"}],D:[20]},GrandChild:{C:[{id:-100,childId:-10}],U:[{id:100,name:"grand1a"}],D:[200]}})});it("should produce a Batch via getSaveBatch",function(){var Y=H.getSaveBatch();expect(Y.operations.length).toBe(9);Ext.each([["create","Parent",[X.newParent]],["create","Child",[X.newChild]],["create","GrandChild",[X.newGrandChild]],["update","Parent",[X.parentRecs[0]]],["update","Child",[X.childRecs[0]]],["update","GrandChild",[X.grandChildRecs[0]]],["destroy","GrandChild",[X.grandChildRecs[1]]],["destroy","Child",[X.childRecs[1]]],["destroy","Parent",[X.parentRecs[1]]]],function(Z,d){var b=Y.operations[d],c;c="operation["+d+"].action=";expect(c+b.action).toBe(c+Z[0]);c="operation["+d+"].type=";expect(c+b.entityType.entityName).toBe(c+Z[1]);c="operation["+d+"].records=";var e=Ext.Array.pluck(b.getRecords(),"id");e=Ext.encode(e);var a=Ext.Array.pluck(Z[2],"id");a=Ext.encode(a);expect(c+e).toBe(c+a)})});it("should progress save batch to completion",function(){var Z=H.createRecord("GrandChild");Z.setChild(X.newChild);expect(Z.id).toBe(-101);expect(Z.data.childId).toBe(-10);var a=H.getSaveBatch();expect(a.operations.length).toBe(9);var Y=a.operations[2].getRecords();expect(Y[0]).toBe(X.newGrandChild);expect(Y[1]).toBe(Z);a.start();J({id:1000});expect(X.newParent.id).toBe(1000);expect(X.newChild.data.parentId).toBe(1000);J({id:2000});expect(X.newChild.id).toBe(2000);expect(X.newGrandChild.data.childId).toBe(2000);expect(Z.data.childId).toBe(2000);J([{cid:Z.id,id:3001},{cid:X.newGrandChild.id,id:3000}]);expect(X.newGrandChild.id).toBe(3000);expect(Z.id).toBe(3001)})});describe("matrix updates",function(){it("should be able to create matrix for new record",function(){var Y=H.getRecord("User",B.id,false).groups();Y.load();J(A);var c=H.createRecord("User");var Z=c.groups();Z.add(Y.getAt(0));var b=H.getSaveBatch();var a=H.getChanges();expect(b.operations.length).toBe(1);expect(a).toEqual({User:{C:[{id:"User-1"}],groups:{C:{"User-1":[42]}}}});b.start();J({id:500});var X=H.getChanges();expect(X).toEqual({User:{groups:{C:{500:[42]}}}})})})})});