describe("Ext.data.reader.Json",function(){var C,B,A,E,D,F;beforeEach(function(){Ext.ClassManager.enableNamespaceParseCache=false;Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.JsonReader",{extend:"Ext.data.Model",fields:[{name:"inter",type:"int"}]});C=new Ext.data.JsonReader({rootProperty:"data",totalProperty:"totalProp",messageProperty:"messageProp",successProperty:"successProp",model:"spec.JsonReader"})});afterEach(function(){Ext.ClassManager.enableNamespaceParseCache=true;Ext.undefine("spec.JsonReader");Ext.data.Model.schema.clear(true)});describe("preserveRawData",function(){it("should not use the raw data object for the model if set to true",function(){C.setPreserveRawData(true);var H={inter:1};var G=C.readRecords([H]).getRecords()[0];G.set("inter",2);expect(H.inter).toBe(1)});it("should be able to modify the raw data object for the model if set to false",function(){C.setPreserveRawData(false);var H={inter:1};var G=C.readRecords([H]).getRecords()[0];G.set("inter",2);expect(H.inter).toBe(2)})});describe("extractors",function(){var G;beforeEach(function(){G=function(H){H=H||{};C=new Ext.data.reader.Json(Ext.applyIf({model:"spec.JsonReader"},H));C.buildExtractors(true)}});afterEach(function(){C=G=null});it("should run function extractors in the reader scope",function(){var H;G({successProperty:function(){H=this;return true}});C.getSuccess({success:true});expect(H).toBe(C)});describe("getTotal",function(){it("should default to total",function(){G();expect(C.getTotal({total:5})).toBe(5)});it("should have no getTotal method if the totalProperty isn't specified",function(){G({totalProperty:""});expect(C.getTotal).toBeUndefined()});it("should read the specified property name",function(){G({totalProperty:"foo"});expect(C.getTotal({foo:10})).toBe(10)});it("should accept a function configuration",function(){G({totalProperty:function(H){return H.big.chain.total}});expect(C.getTotal({big:{chain:{total:65}}})).toBe(65)});describe("JSON",function(){it("should read dot notation",function(){G({totalProperty:"big.chain.total"});expect(C.getTotal({big:{chain:{total:43}}})).toBe(43)});it("should read array notation for numeric values",function(){G({totalProperty:"values[0]"});expect(C.getTotal({values:[9]})).toBe(9)});it("should read array notation for property names",function(){G({totalProperty:'["foo-bar"]'});expect(C.getTotal({"foo-bar":16})).toBe(16)});it("should read array/dot notation",function(){G({totalProperty:"big[0].chain.total"});expect(C.getTotal({big:[{chain:{total:17}}]})).toBe(17)});it("should not read dot chains if simple accessors are used",function(){G({totalProperty:"some.big.chain",useSimpleAccessors:true});expect(C.getTotal({"some.big.chain":88})).toBe(88)})})});describe("success",function(){it("should default to success",function(){G();expect(C.getSuccess({success:true})).toBe(true)});it("should have no getSuccess method if the successProperty isn't specified",function(){G({successProperty:""});expect(C.getSuccess).toBeUndefined()});it("should read the specified property name",function(){G({successProperty:"foo"});expect(C.getSuccess({foo:false})).toBe(false)});it("should accept a function configuration",function(){G({successProperty:function(H){return H.big.chain.success}});expect(C.getSuccess({big:{chain:{success:true}}})).toBe(true)});describe("JSON",function(){it("should read dot notation",function(){G({successProperty:"big.chain.success"});expect(C.getSuccess({big:{chain:{success:true}}})).toBe(true)});it("should read array notation for numeric values",function(){G({successProperty:"values[0]"});expect(C.getSuccess({values:[false]})).toBe(false)});it("should read array notation for property names",function(){G({successProperty:'["foo-bar"]'});expect(C.getSuccess({"foo-bar":false})).toBe(false)});it("should read array/dot notation",function(){G({successProperty:"big[0].chain.success"});expect(C.getSuccess({big:[{chain:{success:true}}]})).toBe(true)});it("should not read dot chains if simple accessors are used",function(){G({successProperty:"some.big.chain",useSimpleAccessors:true});expect(C.getSuccess({"some.big.chain":true})).toBe(true)})})});describe("message",function(){it("should default to undefined",function(){G();expect(C.getMessage).toBeUndefined()});it("should have no getMessage method if the messageProperty isn't specified",function(){G({successProperty:""});expect(C.getSuccess).toBeUndefined()});it("should read the specified property name",function(){G({messageProperty:"foo"});expect(C.getMessage({foo:false})).toBe(false)});it("should accept a function configuration",function(){G({messageProperty:function(H){return H.big.chain.message}});expect(C.getMessage({big:{chain:{message:"msg"}}})).toBe("msg")});describe("JSON",function(){it("should read dot notation",function(){G({messageProperty:"big.chain.message"});expect(C.getMessage({big:{chain:{message:"some message"}}})).toBe("some message")});it("should read array notation for numeric values",function(){G({messageProperty:"values[0]"});expect(C.getMessage({values:["a message"]})).toBe("a message")});it("should read array notation for property names",function(){G({messageProperty:'["foo-bar"]'});expect(C.getMessage({"foo-bar":"new msg"})).toBe("new msg")});it("should read array/dot notation",function(){G({messageProperty:"big[0].chain.message"});expect(C.getMessage({big:[{chain:{message:"stuff"}}]})).toBe("stuff")});it("should not read dot chains if simple accessors are used",function(){G({messageProperty:"some.big.chain",useSimpleAccessors:true});expect(C.getMessage({"some.big.chain":"data"})).toBe("data")})})});describe("root",function(){it("should default to a function returning the main object",function(){var H=[];G();expect(C.getRoot(H)).toBe(H)});it("default to a function returning the main object root isn't specified",function(){var H=[];G({rootProperty:""});expect(C.getRoot(H)).toBe(H)});it("should read the specified property name",function(){var H=[];G({rootProperty:"foo"});expect(C.getRoot({foo:H})).toBe(H)});it("should accept a function configuration",function(){var H=[];G({rootProperty:function(I){return I.big.chain.root}});expect(C.getRoot({big:{chain:{root:H}}})).toBe(H)});describe("JSON",function(){it("should read dot notation",function(){var H=[];G({rootProperty:"big.chain.root"});expect(C.getRoot({big:{chain:{root:H}}})).toBe(H)});it("should read array notation for numeric values",function(){var H=[];G({rootProperty:"values[0]"});expect(C.getRoot({values:[H]})).toBe(H)});it("should read array notation for property names",function(){var H=[];G({rootProperty:'["foo-bar"]'});expect(C.getRoot({"foo-bar":H})).toBe(H)});it("should read array/dot notation",function(){var H=[];G({rootProperty:"big[0].chain.root"});expect(C.getRoot({big:[{chain:{root:H}}]})).toBe(H)});it("should not read dot chains if simple accessors are used",function(){var H=[];G({rootProperty:"some.big.chain",useSimpleAccessors:true});expect(C.getRoot({"some.big.chain":H})).toBe(H)})})});describe("fields",function(){var H={recordCreator:Ext.identityFn};beforeEach(function(){G=function(J,I){Ext.define("spec.JsonFieldTest",{extend:"Ext.data.Model",fields:J});C=new Ext.data.reader.Json({model:"spec.JsonFieldTest",fields:J,useSimpleAccessors:I||false})}});afterEach(function(){Ext.undefine("spec.JsonFieldTest")});it("should read the name if no mapping is specified",function(){G(["field"]);var I=C.readRecords([{field:"val"}],H).getRecords()[0];expect(I.field).toBe("val")});it("should give precedence to the mapping",function(){G([{name:"field",mapping:"somethingElse"}]);var I=C.readRecords([{somethingElse:"a value"}],H).getRecords()[0];expect(I.field).toEqual("a value")});it("should accept a function",function(){G([{name:"field",mapping:function(J){return J.complex.chain.value}}]);var I=C.readRecords([{complex:{chain:{value:2}}}],H).getRecords()[0];expect(I.field).toBe(2)});it("should ignore certain falsy mapping values",function(){G([{name:"field",mapping:undefined},{name:"field2",mapping:null},{name:"field3",mapping:""}]);var I=C.readRecords([{field:"val",field2:"val2",field3:"val3"}],H).getRecords()[0];expect(I.field).toBe("val");expect(I.field2).toBe("val2");expect(I.field3).toBe("val3")});it("should allow zero value for mapping",function(){G([{name:"field",mapping:0}]);var J=C.readRecords([{0:"woo"}],H).getRecords()[0];var I=C.readRecords([["T"]],H).getRecords()[0];expect(J.field).toBe("woo");expect(I.field).toBe("T")});describe("JSON",function(){it("should read dot notation",function(){G([{name:"field",mapping:"some.value"}]);var I=C.readRecords([{some:{value:"mapped"}}],H).getRecords()[0];expect(I.field).toBe("mapped")});it("should handle dot notation with an undefined property",function(){G([{name:"field",mapping:"some.value"}]);var I=C.readRecords([{some:{}}],H).getRecords()[0];expect(I.field).toBeUndefined()});it("should handle dot notation with nested undefined properties",function(){G([{name:"field",mapping:"some.deep.nested.value"}]);var I=C.readRecords([{some:{}}],H).getRecords()[0];expect(I.field).toBeUndefined()});it("should read array notation for numeric values",function(){G([{name:"field",mapping:"values[0]"}]);var I=C.readRecords([{values:["a"]}],H).getRecords()[0];expect(I.field).toBe("a")});it("should read array notation for property names",function(){G([{name:"field",mapping:'["a-prop"]'}]);var I=C.readRecords([{"a-prop":"woo"}],H).getRecords()[0];expect(I.field).toBe("woo")});it("should read array/dot notation",function(){G([{name:"field",mapping:"big[0].chain.value"}]);var I=C.readRecords([{big:[{chain:{value:45}}]}],H).getRecords()[0];expect(I.field).toBe(45)});it("should handle array/dot notation with nested undefined properties",function(){G([{name:"field",mapping:"big[0].deep.chain.value"}]);var I=C.readRecords([{big:[{deep:{}}]}],H).getRecords()[0];expect(I.field).toBeUndefined()});it("should not read dot chains if simple accessors are used",function(){G([{name:"field",mapping:"a.long.name"}],true);var I=C.readRecords([{"a.long.name":"sixty"}],H).getRecords()[0];expect(I.field).toBe("sixty")});it("should handle dot chains with undefined values if simple accessors are used",function(){G([{name:"field",mapping:"a.long.name"}],true);var I=C.readRecords([{}],H).getRecords()[0];expect(I.field).toBeUndefined()})})})});describe("reading records",function(){beforeEach(function(){Ext.define("spec.JsonReaderTest",{extend:"Ext.data.Model",fields:[{name:"id"},{name:"floater",type:"float"},{name:"bool",type:"boolean"},{name:"inter",type:"integer"},{name:"class",type:"string"},{name:"string",type:"string",convert:function(G){return"modified/"+G}},{name:"withMap",mapping:"someMap"}]});C=new Ext.data.reader.Json({rootProperty:"data",idProperty:"id",successProperty:"successProp",totalProperty:"totalProp",messageProperty:"message",model:"spec.JsonReaderTest"});B={id:1,bool:true,inter:8675,floater:1.23,string:"Ed","class":"person"};A={id:2,bool:false,inter:309,floater:4.56,string:"Nick","class":"person"};E=C.readRecords({data:[B],successProp:true,totalProp:2});D=C.readRecords({data:[A],successProp:false,totalProp:6,message:"Failed"});F=C.readRecords({data:A,successProp:true,totalProp:6})});afterEach(function(){Ext.undefine("spec.JsonReaderTest")});it("should read the success property",function(){expect(E.getSuccess()).toBe(true);expect(D.getSuccess()).toBe(false)});it("should read the total record count",function(){expect(E.getTotal()).toBe(2);expect(D.getTotal()).toBe(6)});it("should read records correctly",function(){var G=E.getRecords()[0].getData();expect(G.id).toBe(B.id);expect(G.floater).toBe(B.floater);expect(G.bool).toBe(B.bool);expect(G.inter).toBe(B.inter)});it("should be able to have fields as reserved words",function(){var G=E.getRecords()[0].getData();expect(G["class"]).toBe("person")});it("should read records correctly if there was just a single object instead of an array of data",function(){var G=F.getRecords()[0].getData();expect(G.id).toBe(A.id);expect(G.floater).toBe(A.floater);expect(G.bool).toBe(A.bool);expect(G.inter).toBe(A.inter)});it("should still read on failure by default",function(){expect(D.getRecords()[0].getId()).toBe(2)});it("should ignore values records/total when success is false & readRecordsOnFailure is false",function(){C.setReadRecordsOnFailure(false);D=C.readRecords({data:[A],successProp:false,totalProp:6,message:"Failed"});expect(D.getRecords()).toEqual([]);expect(D.getTotal()).toBe(0);expect(D.getMessage()).toBe("Failed")});it("should respect the field's convert function",function(){var G=E.getRecords()[0].getData();expect(G.string).toBe("modified/Ed")});it("should be able to load a single record",function(){var G=C.readRecords({data:B}).getRecords()[0].getData();expect(G.id).toBe(B.id);expect(G.floater).toBe(B.floater);expect(G.bool).toBe(B.bool);expect(G.inter).toBe(B.inter)});it("should handle record instances being in the data",function(){var G=C.readRecords({data:[B,new spec.JsonReaderTest(A)],successProp:true}).getRecords()[1].getData();expect(G.id).toBe(A.id);expect(G.floater).toBe(A.floater);expect(G.bool).toBe(A.bool);expect(G.inter).toBe(A.inter)});describe("readOptions",function(){it("should return what we construct when we pass recordCreator",function(){var G=C.readRecords({data:[B,A]},{recordCreator:function(H){return H}}).getRecords();expect(G[0]).toEqual(B);expect(G[1]).toEqual(A)});it("should process mappings",function(){var G=C.readRecords({data:[{someMap:"foo"}]},{recordCreator:function(H){return H}}).getRecords();expect(G[0]).toEqual({withMap:"foo",someMap:"foo"})})})});describe("loading with a 'record' property",function(){var H,G;beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","email"]});C=new Ext.data.reader.Json({model:"spec.User",rootProperty:"users",record:"user"});H={users:[{user:{id:1,name:"Ed Spencer",email:"ed@sencha.com"}},{user:{id:2,name:"Abe Elias",email:"abe@sencha.com"}}]};G=C.readRecords(H)});afterEach(function(){Ext.undefine("spec.User")});it("should parse the correct number of results",function(){expect(G.getCount()).toEqual(2)});it("should parse each record correctly",function(){var I=G.getRecords(),K=I[0],J=I[1];expect(K.get("name")).toBe("Ed Spencer");expect(J.get("name")).toBe("Abe Elias")})});describe("calling model onLoad",function(){beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"],onLoad:function(){}})});afterEach(function(){Ext.undefine("spec.User")});it("should call the template method for each record",function(){var G=spyOn(spec.User.prototype,"onLoad");C=new Ext.data.reader.Json({model:"spec.User"});C.read([{id:1},{id:2},{id:3},{id:4},{id:5},{id:6},{id:7}]);expect(G.callCount).toBe(7)});it("should call the template method after processing associations",function(){var G;spyOn(spec.User.prototype,"onLoad").andCallFake(function(){G=this.orders().getCount()});Ext.define("spec.Order",{extend:"Ext.data.Model",fields:[{name:"userId",reference:"User"}]});C=new Ext.data.reader.Json({model:"spec.User"});C.read([{id:1,orders:[{id:1}]}]);expect(G).toBe(1);Ext.undefine("spec.Order")})});describe("loading nested data",function(){var H={"users":[{"id":123,"name":"Ed","addresses":[{"line1":"525 University Avenue","line2":"Suite 23","town":"Palo Alto"}],"orders":[{"id":50,"total":100,"order_items":[{"id":20,"price":40,"quantity":2,"product":{"id":1000,"name":"MacBook Pro"}},{"id":21,"price":20,"quantity":1,"product":{"id":1001,"name":"iPhone"}}]},{"id":51,"total":10,"order_items":[{"id":22,"price":10,"quantity":1,"product":{"id":1002,"name":"iPad"}}]}]}]};beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name"],hasMany:[{model:"spec.Order",name:"orders"},{model:"spec.Address",name:"addresses"}],proxy:{type:"rest",reader:{type:"json",rootProperty:"users"}}});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","line1","line2","town"],belongsTo:"spec.User"});Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","total"],hasMany:{model:"spec.OrderItem",name:"orderItems",associationKey:"order_items"},belongsTo:"spec.User"});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price","quantity","order_id","product_id"],belongsTo:["spec.Order",{model:"spec.Product",getterName:"getProduct",associationKey:"product"}]});Ext.define("spec.Product",{extend:"Ext.data.Model",fields:["id","name"],hasMany:{model:"spec.OrderItem",name:"orderItems"}})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Address");Ext.undefine("spec.Order");Ext.undefine("spec.OrderItem");Ext.undefine("spec.Product")});function G(I){return new Ext.data.reader.Json(Ext.apply({},I,{model:"spec.User",rootProperty:"users"}))}it("should set implicitIncludes to true by default",function(){C=G();expect(C.getImplicitIncludes()).toBe(true)});it("should not parse includes if implicitIncludes is set to false",function(){C=G({implicitIncludes:false});var I=C.read(H),K=I.getRecords()[0],J=K.orders();expect(J.getCount()).toBe(0)});describe("when reading nested data",function(){var J,N,M,K,L,I;beforeEach(function(){C=G();J=C.read(H);N=J.getRecords()[0];I=N.addresses();M=N.orders();K=M.first().orderItems();L=K.first().getProduct()});it("should populate first-order associations",function(){expect(M.getCount()).toBe(2);expect(I.getCount()).toBe(1)});it("should populate second-order associations",function(){expect(K.getCount()).toBe(2)});it("should populate belongsTo associations",function(){expect(L.get("name")).toBe("MacBook Pro")});it("should ignore associations where the model isn't yet loaded",function(){Ext.define("spec.Employee",{extend:"Ext.data.Model",fields:["id","name",{name:"projectId",reference:"Project"}]});C=new Ext.data.reader.Json({model:"spec.Employee"});expect(function(){C.read({id:1,name:"Foo"})}).not.toThrow()})})});describe("reconfiguring via metadata",function(){it("should call onMetaChange",function(){var G={some:"meta data"};spyOn(C,"onMetaChange").andReturn();spyOn(C,"getRoot").andReturn([]);C.readRecords({metaData:G});expect(C.onMetaChange).toHaveBeenCalledWith(G)});it("should accept a custom meta property",function(){C.setMetaProperty("foo.bar.baz");C.buildExtractors(true);spyOn(C,"onMetaChange").andReturn();spyOn(C,"getRoot").andReturn([]);var G={};var H={foo:{bar:{baz:G}}};C.readRecords(H);expect(C.onMetaChange).toHaveBeenCalledWith(G)})});describe("reading xhr",function(){var H={responseText:'{ "success": true, "users": [{"name": "Ben", "location": "Boston"}, {"name": "Mike", "location": "Redwood City"}, {"name": "Nick", "location": "Kansas City"}] }'},I={responseText:"this is not JSON"};beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name","location"]});C=new Ext.data.reader.Json({rootProperty:"users",model:"spec.User",listeners:{exception:function(L,M,K,J){}}})});afterEach(function(){Ext.undefine("spec.User")});function G(J){return C.read(J)}describe("if there is a responseText property",function(){describe("if there is valid JSON",function(){it("should be successful",function(){expect(G(H).getSuccess()).toBe(true)});it("should return the expected number of records",function(){expect(G(H).getCount()).toBe(3)});it("should not return a non-empty dataset",function(){expect(G(H).getRecords().length).toBe(3)})});describe("if there is invalid JSON",function(){it("should not be successful",function(){expect(G(I).getSuccess()).toBe(false)});it("should not return any records",function(){expect(G(I).getTotal()).toBe(0)});it("should return any empty dataset",function(){expect(G(I).getRecords().length).toBe(0)})})});describe("if there is no responseText property",function(){it("should return an empty dataset",function(){expect(G("something").getCount()).toBe(0)})})})});