describe("Ext.data.TreeStore",function(){var A,E,D,C=Ext.define(null,{extend:"Ext.data.Model",fields:["name"],proxy:{type:"ajax",url:"foo.json",reader:{type:"json"}}}),F=Ext.define(null,{extend:"Ext.data.Model",idProperty:"id",fields:[{name:"id",type:"int",allowNull:true},{name:"task",type:"string"},{name:"duration",type:"string"}]});function B(H,I,K){var G={fn:K||Ext.emptyFn},J=spyOn(G,"fn");H.addListener(I,G.fn);return J}beforeEach(function(){D={success:true,children:[{id:1,name:"aaa"},{id:2,name:"bbb",children:[{id:3,name:"ccc"},{id:4,name:"ddd",children:[{id:5,name:"eee",leaf:true}]}]},{id:6,name:"fff",children:[{id:7,name:"ggg"}]}]};MockAjaxManager.addMethods();var G=function(H,I){Ext.Ajax.mockComplete({status:I||200,responseText:H||"response"})};E=function(H,I){H.load(I);G(Ext.encode(D))}});afterEach(function(){MockAjaxManager.removeMethods()});describe("loading data",function(){describe("when loading asynchronously from a url",function(){describe("if the root node is expanded",function(){beforeEach(function(){spyOn(Ext.data.TreeStore.prototype,"load").andCallFake(function(){});A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,id:0,name:"Root Node"}})});it("should load the TreeStore automatically",function(){expect(A.load).toHaveBeenCalled()})});describe("if the root node is not expanded",function(){beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,autoLoad:false,root:{expanded:false,id:0,name:"Root Node"}})});it("should not be loading before load is called",function(){expect(A.isLoading()).toBe(false)});it("should be loading while the request is still in progress",function(){A.load();expect(A.isLoading()).toBe(true)});it("should not be loading after the request has finished",function(){E(A);expect(A.isLoading()).toBe(false)});describe("if autoLoad is set to true",function(){beforeEach(function(){spyOn(Ext.data.TreeStore.prototype,"load").andCallFake(function(){});A=Ext.create("Ext.data.TreeStore",{model:C,autoLoad:true,root:{expanded:false,id:0,name:"Root Node"}})});it("should load the TreeStore automatically",function(){expect(A.load).toHaveBeenCalled()})})});describe("when reloading a store that already contains records",function(){beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,autoLoad:false,root:{expanded:false,id:0,name:"Root Node"}});A.fillNode(A.getRootNode(),A.getProxy().getReader().readRecords(D.children).getRecords())});describe("if records have been removed from the store",function(){beforeEach(function(){A.getNodeById(1).remove();A.getNodeById(5).remove();A.getNodeById(4).remove()});describe("if the node being loaded is the root node",function(){beforeEach(function(){E(A)});it("should reset the store's removed array",function(){expect(A.getRemovedRecords().length).toBe(0)})});describe("if the node being loaded is not the root node",function(){var G;beforeEach(function(){E(A,{node:A.getNodeById(2)})});it("should only remove records from the removed array that were previously descendants of the node being reloaded",function(){G=A.getRemovedRecords();expect(G.length).toBe(1);expect(G[0].getId()).toBe(1)})});describe("if clearRemovedOnLoad is false",function(){var G;beforeEach(function(){A.clearRemovedOnLoad=false;E(A)});afterEach(function(){A.clearRemovedOnLoad=true});it("should not alter the store's removed array",function(){G=A.getRemovedRecords();expect(G.length).toBe(3);expect(G[0].getId()).toBe(1);expect(G[1].getId()).toBe(5);expect(G[2].getId()).toBe(4)})})})});describe("when the records in the response data have an index field",function(){beforeEach(function(){D={success:true,children:[{id:1,name:"aaa",index:2},{id:2,name:"bbb",index:0,children:[{id:3,name:"ccc",index:1},{id:4,name:"ddd",index:0}],expanded:true},{id:5,name:"eee",index:1}]};A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,id:0,name:"Root Node"}});E(A)});it("should sort the root level nodes by index",function(){expect(A.getRootNode().childNodes[0].getId()).toBe(2);expect(A.getRootNode().childNodes[1].getId()).toBe(5);expect(A.getRootNode().childNodes[2].getId()).toBe(1)});it("should sort descendants by index",function(){expect(A.getNodeById(2).firstChild.getId()).toBe(4);expect(A.getNodeById(2).lastChild.getId()).toBe(3)});it("should sort folders first, then in index order",function(){expect(A.getAt(0).getId()).toBe(2);expect(A.getAt(1).getId()).toBe(4);expect(A.getAt(2).getId()).toBe(3);expect(A.getAt(3).getId()).toBe(5);expect(A.getAt(4).getId()).toBe(1)})})});describe("clearOnLoad",function(){beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,id:0,name:"Root Node"}})});it("should remove existing nodes with clearOnLoad: true",function(){D={children:[]};var G=A.getRootNode();G.appendChild({id:"node1",text:"A"});G.appendChild({id:"node2",text:"B"});E(A);expect(A.getRootNode().childNodes.length).toBe(0)});it("should leave existing nodes with clearOnLoad: false",function(){A.clearOnLoad=false;D={children:[]};var G=A.getRootNode();G.appendChild({id:"node1",text:"A"});G.appendChild({id:"node2",text:"B"});E(A);expect(A.getRootNode().childNodes.length).toBe(2)});it("should ignore dupes with clearOnLoad: false",function(){A.clearOnLoad=false;D={children:[{id:"node1",text:"A"},{id:"node3",text:"C"}]};var G=A.getRootNode();G.appendChild({id:"node1",text:"A"});G.appendChild({id:"node2",text:"B"});E(A);expect(A.getRootNode().childNodes.length).toBe(3)})})});describe("saving data",function(){var H,G,I;beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,name:"Root Node"}});E(A);I=spyOn(A,"sync").andReturn()});describe("creating records",function(){describe("appending a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getRootNode().appendChild(H)});it("should add the node to getNewRecords",function(){G=A.getNewRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should not add anything to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("inserting a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getNodeById(2).insertBefore(H,A.getNodeById(4))});it("should add the node to getNewRecords",function(){G=A.getNewRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("appending and inserting multiple nodes",function(){var J,L,K;beforeEach(function(){J=new C({name:"1"});L=new C({name:"2"});K=new C({name:"3"});A.getRootNode().appendChild(J);A.getNodeById(2).insertBefore(L,A.getNodeById(4));L.appendChild(K)});it("should add the nodes to getNewRecords",function(){var M=A.getNewRecords();expect(M.length).toBe(3);expect(Ext.Array.contains(M,J)).toBe(true);expect(Ext.Array.contains(M,L)).toBe(true);expect(Ext.Array.contains(M,K)).toBe(true)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("when the index field is persistent",function(){beforeEach(function(){C.getField("index").persist=true});afterEach(function(){C.getField("index").persist=false});describe("appending a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getRootNode().appendChild(H)});it("should add the node to getNewRecords",function(){G=A.getNewRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)})});describe("inserting a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getNodeById(2).insertBefore(H,A.getNodeById(3))});it("should add the node to getNewRecords",function(){G=A.getNewRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should add all of its sibling nodes that come after the insertion point to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(2);expect(Ext.Array.contains(G,A.getNodeById(3))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(4))).toBe(true)})})});describe("when autoSync is true",function(){beforeEach(function(){A.autoSync=true});describe("appending a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getRootNode().appendChild(H)});it("should sync the store",function(){expect(I.callCount).toBe(1)})});describe("inserting a single node",function(){beforeEach(function(){H=new C({name:"Phil"});A.getNodeById(2).insertBefore(H,A.getNodeById(4))});it("should sync the store",function(){expect(I.callCount).toBe(1)})})})});describe("updating records",function(){describe("updating multiple records",function(){beforeEach(function(){A.getNodeById(2).set("name","222");A.getNodeById(3).set("name","333")});it("should add the nodes to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(2);expect(Ext.Array.contains(G,A.getNodeById(2))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(3))).toBe(true)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("moving records",function(){describe("within the same parent node",function(){beforeEach(function(){A.getRootNode().insertBefore(A.getNodeById(6),A.getNodeById(1))});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("to a different parent node",function(){beforeEach(function(){A.getNodeById(4).insertBefore(A.getNodeById(1),A.getNodeById(5))});it("should add the node to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(1);expect(G[0]).toBe(A.getNodeById(1))});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})})});describe("moving records when the index field is persistent",function(){beforeEach(function(){C.getField("index").persist=true});afterEach(function(){C.getField("index").persist=false});describe("within the same parent node",function(){beforeEach(function(){A.getRootNode().insertBefore(A.getNodeById(6),A.getNodeById(1))});it("should add the node and all sibling nodes after it to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(3);expect(Ext.Array.contains(G,A.getNodeById(1))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(2))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(6))).toBe(true)})});describe("to a different parent node",function(){beforeEach(function(){A.getNodeById(4).insertBefore(A.getNodeById(1),A.getNodeById(5))});it("should add the node, all sibling nodes after it's insertion point, and all siblings after its removal point to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(4);expect(Ext.Array.contains(G,A.getNodeById(1))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(2))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(5))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(6))).toBe(true)})})});describe("moving records when autoSync is true",function(){beforeEach(function(){A.autoSync=true});describe("within the same parent node",function(){beforeEach(function(){A.getRootNode().insertBefore(A.getNodeById(6),A.getNodeById(1))});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("to a different parent node",function(){beforeEach(function(){A.getNodeById(4).insertBefore(A.getNodeById(1),A.getNodeById(5))});it("should sync the store",function(){expect(I.callCount).toBe(1)})})})});describe("removing records",function(){describe("removing a single record",function(){beforeEach(function(){H=A.getNodeById(1).remove()});it("should add the node to getRemovedRecords",function(){G=A.getRemovedRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()});it("should not add phantom records to the removed collection",function(){var K=new C(),J=A.getRootNode();J.appendChild(K);J.removeChild(K);expect(Ext.Array.contains(A.getRemovedRecords(),K)).toBe(false)})});describe("removing multiple records",function(){var J;beforeEach(function(){H=A.getNodeById(1).remove();J=A.getNodeById(4).remove()});it("should add the nodes to getRemovedRecords",function(){G=A.getRemovedRecords();expect(G.length).toBe(2);expect(Ext.Array.contains(G,H)).toBe(true);expect(Ext.Array.contains(G,J)).toBe(true)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(I).not.toHaveBeenCalled()})});describe("when the index field is persistent",function(){beforeEach(function(){C.getField("index").persist=true});afterEach(function(){C.getField("index").persist=false});describe("removing a single record",function(){beforeEach(function(){H=A.getNodeById(1).remove()});it("should add the node to getRemovedRecords",function(){G=A.getRemovedRecords();expect(G.length).toBe(1);expect(G[0]).toBe(H)});it("should add all siblings after the node's removal point to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(2);expect(Ext.Array.contains(G,A.getNodeById(2))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(6))).toBe(true)})})});describe("when autoSync is true",function(){beforeEach(function(){A.autoSync=true});describe("removing a single record",function(){beforeEach(function(){A.getNodeById(1).remove()});it("should sync the store",function(){expect(I.callCount).toBe(1)})})})});describe("sorting",function(){var J=function(K,L){var M=K.data.name,N=L.data.name;return M<N?1:K===L?0:-1};describe("when sorting recursively",function(){beforeEach(function(){A.getRootNode().sort(J,true)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)})});describe("when sorting non-recursively",function(){beforeEach(function(){A.getRootNode().sort(J)});it("should not add any records to getUpdatedRecords",function(){expect(A.getUpdatedRecords().length).toBe(0)})});describe("when the index field is persistent and autoSync is true",function(){beforeEach(function(){C.getField("index").persist=true;A.autoSync=true});afterEach(function(){C.getField("index").persist=false});describe("when sorting recursively",function(){beforeEach(function(){A.getRootNode().sort(J,true)});it("should add all nodes at all levels that had an index change to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(4);expect(Ext.Array.contains(G,A.getNodeById(1))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(3))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(4))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(6))).toBe(true)});it("should sync the store",function(){expect(I.callCount).toBe(1)})});describe("when sorting non-recursively",function(){beforeEach(function(){A.getRootNode().sort(J)});it("should add all nodes at depth 1 that had an index change to getUpdatedRecords",function(){G=A.getUpdatedRecords();expect(G.length).toBe(2);expect(Ext.Array.contains(G,A.getNodeById(1))).toBe(true);expect(Ext.Array.contains(G,A.getNodeById(6))).toBe(true)});it("should sync the store",function(){expect(I.callCount).toBe(1)})})})})});describe("Loading TreeStore using root config",function(){it('should load the root nodes children using Proxy\'s "root" config',function(){var G=Ext.create("Ext.data.TreeStore",{root:{expanded:true,CHILDREN:[{text:"detention",leaf:true},{text:"homework",expanded:true,CHILDREN:[{text:"book report",leaf:true},{text:"alegrbra",leaf:true}]},{text:"buy lottery tickets",leaf:true}]},proxy:{type:"memory",reader:{type:"json",root:"CHILDREN"}}});var H=G.getRootNode().childNodes;expect(H.length).toBe(3);expect(H[0].childNodes.length).toBe(0);expect(H[1].childNodes.length).toBe(2);expect(H[2].childNodes.length).toBe(0)})});describe("default node id",function(){it("Should use generate an ID if the idProperty is null in the incoming data",function(){A=Ext.create("Ext.data.TreeStore",{model:F,defaultRootId:null,root:{}});expect(A.getRootNode().getId()).not.toBeNull()});it('Should use "root" as the defaultRootId, and parse that according to the idProperty field type',function(){A=Ext.create("Ext.data.TreeStore",{model:F,root:{}});expect(isNaN(A.getRootNode().getId())).toBe(true)});it("Should use the configured defaultRootId, and parse that according to the idProperty field type",function(){A=Ext.create("Ext.data.TreeStore",{model:F,defaultRootId:-1,root:{}});expect(A.getRootNode().getId()).toBe(-1)})});describe("moving root node between trees",function(){it("should move root and all descendants from source tree into destination tree",function(){var G=Ext.create("Ext.data.TreeStore",{root:{expanded:true,children:[{text:"Test",leaf:true,id:"testId"}]}}),I=G.getRootNode(),J=I.firstChild,H=Ext.create("Ext.data.TreeStore");expect(I.rootOf===G.tree).toBe(true);expect(G.getNodeById("testId")===J).toBe(true);H.setRootNode(G.getRootNode());expect(I.rootOf===H.tree).toBe(true);expect(H.getRootNode()===I).toBe(true);expect(H.getNodeById("testId")===J).toBe(true);expect(G.getNodeById("testId")).toBeFalsy();expect(G.getRootNode()).toBeFalsy()})});describe("events",function(){var J,G,L,H,K,I;beforeEach(function(){A=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true,children:[{text:"Child 1",leaf:true},{text:"Child 2",leaf:true},{text:"Child 3",leaf:true},{text:"Child 4",leaf:true}]}});G=A.getRootNode()});it("should fire insert event",function(){J=B(G,"insert").andCallThrough();K=G.firstChild;L=G.insertBefore({text:"New First"},K);I=J.calls[0].args;expect(J.calls.length).toBe(1);expect(I[0]).toBe(G);expect(I[1]).toBe(L);expect(I[2]).toBe(K)});it("should fire append event",function(){J=B(G,"append").andCallThrough();L=G.appendChild({text:"New Last"});I=J.calls[0].args;expect(J.calls.length).toBe(1);expect(I[0]).toBe(G);expect(I[1]).toBe(L);expect(I[2]).toBe(4)});it("should fire remove event",function(){J=B(G,"remove").andCallThrough();H=G.removeChild(G.firstChild);I=J.calls[0].args;expect(J.calls.length).toBe(1);expect(I[0]).toBe(G);expect(I[1]).toBe(H);expect(I[2]).toBe(false)});it("should fire update event",function(){J=B(A,"update").andCallThrough();G.firstChild.set("text","New Text");I=J.calls[0].args;expect(J.calls.length).toBe(1);expect(I[0]).toBe(A);expect(I[1]).toBe(G.firstChild);expect(I[2]).toBe("edit");expect(I[3]).toEqual(["text"])});describe("event ordering",function(){it("should fire events in the correct order",function(){A=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true}});G=A.getRoot();var M=[],N={id:"A",leaf:false,expanded:true,children:[{id:"A.A",leaf:true},{id:"A.B",leaf:true},{id:"A.C",leaf:false,expanded:true,children:[{id:"A.C.A",leaf:true},{id:"A.C.B",leaf:true}]},{id:"A.D",leaf:true}]};G.on("append",function(P,Q,O){M.push(Q.getPath()+" | "+P.getPath())});G.appendChild(N);M=M.join(", ");expect(M).toBe("/root/A | /root, /root/A/A.A | /root/A, /root/A/A.B | /root/A, /root/A/A.C | /root/A, /root/A/A.C/A.C.A | /root/A/A.C, /root/A/A.C/A.C.B | /root/A/A.C, /root/A/A.D | /root/A");A.destroy()})})});describe("beforeload",function(){it("should no clear node descendants if a function binded to beforeload return false",function(){var G=false;A=Ext.create("Ext.data.TreeStore",{model:C,autoLoad:false,root:{expanded:false,id:0,name:"Root Node",children:[{id:1}]}});A.on("beforeload",function(H){expect(H.getRootNode().firstChild).not.toBeNull();G=true;return false});A.load();waitsFor(function(){return G})})});describe("appending to leaf nodes",function(){beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,id:0,name:"Root Node"}});A.fillNode(A.getRootNode(),A.getProxy().getReader().readRecords(D.children).records)});it("should convert leaf nodes to branch nodes.",function(){var G=A.getNodeById(5);expect(G.isLeaf()).toBe(true);G.appendChild({name:"eee-child"});expect(G.isLeaf()).toBe(false)})});describe("heterogeneous TreeStores",function(){var G,H;beforeEach(function(){H=Ext.data.Model.schema;H.setNamespace("spec");Ext.define("spec.Territory",{extend:"Ext.data.TreeModel",idProperty:"territoryName",fields:[{name:"territoryName",mapping:"territoryName",convert:undefined}]}),Ext.define("spec.Country",{extend:"Ext.data.TreeModel",idProperty:"countryName",fields:[{name:"countryName",mapping:"countryName",convert:undefined}]}),Ext.define("spec.City",{extend:"Ext.data.TreeModel",idProperty:"cityName",fields:[{name:"cityName",mapping:"cityName",convert:undefined}]});G={children:[{mtype:"Territory",territoryName:"North America",children:[{mtype:"Country",countryName:"USA",children:[{mtype:"City",cityName:"Redwood City",leaf:true},{mtype:"City",cityName:"Frederick, MD",leaf:true}]},{mtype:"Country",countryName:"Canada",children:[{mtype:"City",cityName:"Vancouver",leaf:true},{mtype:"City",cityName:"Toronto",leaf:true}]}]},{mtype:"Territory",territoryName:"Europe, ME, Africa",expanded:true,children:[{mtype:"Country",countryName:"England",children:[{mtype:"City",cityName:"Nottingham",leaf:true},{mtype:"City",cityName:"London",leaf:true}]},{mtype:"Country",countryName:"Netherlands",children:[{mtype:"City",cityName:"Amsterdam",leaf:true},{mtype:"City",cityName:"Haaksbergen",leaf:true}]}]}]}});afterEach(function(){Ext.undefine("spec.Territory");Ext.undefine("spec.Country");Ext.undefine("spec.City");H.clear(true)});it("should use the parentNode's childType to resolve child node models if no typeProperty is used on Reader",function(){Ext.define("spec.World",{extend:"Ext.data.TreeModel",childType:"Territory"});spec.Territory.prototype.childType="Country";spec.Country.prototype.childType="City";A=new Ext.data.TreeStore({root:G,model:"spec.World",proxy:{type:"memory"}});var L=A.getRootNode(),Q=L.childNodes[0],K=L.childNodes[1],O,P,I=Q.childNodes[0],J=I.childNodes[0],S=I.childNodes[1],T=Q.childNodes[1],N=T.childNodes[0],R=T.childNodes[1],M=I.appendChild({cityName:"Sacramento",leaf:true});expect(Q instanceof spec.Territory).toBe(true);expect(K instanceof spec.Territory).toBe(true);expect(Q.get("territoryName")).toBe("North America");expect(K.get("territoryName")).toBe("Europe, ME, Africa");expect(I instanceof spec.Country).toBe(true);expect(T instanceof spec.Country).toBe(true);expect(I.get("countryName")).toBe("USA");expect(T.get("countryName")).toBe("Canada");expect(J instanceof spec.City).toBe(true);expect(S instanceof spec.City).toBe(true);expect(M instanceof spec.City).toBe(true);expect(N instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(J.get("cityName")).toBe("Redwood City");expect(S.get("cityName")).toBe("Frederick, MD");expect(M.get("cityName")).toBe("Sacramento");expect(N.get("cityName")).toBe("Vancouver");expect(R.get("cityName")).toBe("Toronto");O=K.appendChild({mtype:"Country",countryName:"Spain"});expect(O instanceof spec.Country).toBe(true);expect(O.get("countryName")).toBe("Spain");P=O.appendChild({mtype:"City",cityName:"Madrid"});expect(P instanceof spec.City).toBe(true);expect(P.get("cityName")).toBe("Madrid")});it("should use the store's model namespace to resolve child node models if short form typeProperty is used",function(){A=new Ext.data.TreeStore({model:"spec.Territory",root:G,proxy:{type:"memory",reader:{typeProperty:"mtype"}}});var L=A.getRootNode(),N=L.childNodes[0],K=L.childNodes[1],I=N.childNodes[0],J=I.childNodes[0],P=I.childNodes[1],Q=N.childNodes[1],M=Q.childNodes[0],O=Q.childNodes[1];expect(N instanceof spec.Territory).toBe(true);expect(K instanceof spec.Territory).toBe(true);expect(N.get("territoryName")).toBe("North America");expect(K.get("territoryName")).toBe("Europe, ME, Africa");expect(I instanceof spec.Country).toBe(true);expect(Q instanceof spec.Country).toBe(true);expect(I.get("countryName")).toBe("USA");expect(Q.get("countryName")).toBe("Canada");expect(J instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(M instanceof spec.City).toBe(true);expect(O instanceof spec.City).toBe(true);expect(J.get("cityName")).toBe("Redwood City");expect(P.get("cityName")).toBe("Frederick, MD");expect(M.get("cityName")).toBe("Vancouver");expect(O.get("cityName")).toBe("Toronto")});it("should use the typeProperty's namespace property to resolve model class names",function(){A=new Ext.data.TreeStore({root:G,proxy:{type:"memory",reader:{typeProperty:{name:"mtype",namespace:"spec"}}}});var L=A.getRootNode(),N=L.childNodes[0],K=L.childNodes[1],I=N.childNodes[0],J=I.childNodes[0],P=I.childNodes[1],Q=N.childNodes[1],M=Q.childNodes[0],O=Q.childNodes[1];expect(N instanceof spec.Territory).toBe(true);expect(K instanceof spec.Territory).toBe(true);expect(N.get("territoryName")).toBe("North America");expect(K.get("territoryName")).toBe("Europe, ME, Africa");expect(I instanceof spec.Country).toBe(true);expect(Q instanceof spec.Country).toBe(true);expect(I.get("countryName")).toBe("USA");expect(Q.get("countryName")).toBe("Canada");expect(J instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(M instanceof spec.City).toBe(true);expect(O instanceof spec.City).toBe(true);expect(J.get("cityName")).toBe("Redwood City");expect(P.get("cityName")).toBe("Frederick, MD");expect(M.get("cityName")).toBe("Vancouver");expect(O.get("cityName")).toBe("Toronto")});it("should use the typeProperty's map property to resolve model class names",function(){A=new Ext.data.TreeStore({root:G,proxy:{type:"memory",reader:{typeProperty:{name:"mtype",map:{Territory:"spec.Territory",Country:"spec.Country",City:"spec.City"}}}}});var L=A.getRootNode(),N=L.childNodes[0],K=L.childNodes[1],I=N.childNodes[0],J=I.childNodes[0],P=I.childNodes[1],Q=N.childNodes[1],M=Q.childNodes[0],O=Q.childNodes[1];expect(N instanceof spec.Territory).toBe(true);expect(K instanceof spec.Territory).toBe(true);expect(N.get("territoryName")).toBe("North America");expect(K.get("territoryName")).toBe("Europe, ME, Africa");expect(I instanceof spec.Country).toBe(true);expect(Q instanceof spec.Country).toBe(true);expect(I.get("countryName")).toBe("USA");expect(Q.get("countryName")).toBe("Canada");expect(J instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(M instanceof spec.City).toBe(true);expect(O instanceof spec.City).toBe(true);expect(J.get("cityName")).toBe("Redwood City");expect(P.get("cityName")).toBe("Frederick, MD");expect(M.get("cityName")).toBe("Vancouver");expect(O.get("cityName")).toBe("Toronto")});it("should CALL the typeProperty to resolve model class names if it is a function",function(){var N;A=new Ext.data.TreeStore({root:G,proxy:{type:"memory",reader:{typeProperty:function(S){N=this;return"spec."+S.mtype}}}});var L=A.getRootNode(),O=L.childNodes[0],K=L.childNodes[1],I=O.childNodes[0],J=I.childNodes[0],Q=I.childNodes[1],R=O.childNodes[1],M=R.childNodes[0],P=R.childNodes[1];expect(N===A.getProxy().getReader());expect(O instanceof spec.Territory).toBe(true);expect(K instanceof spec.Territory).toBe(true);expect(O.get("territoryName")).toBe("North America");expect(K.get("territoryName")).toBe("Europe, ME, Africa");expect(I instanceof spec.Country).toBe(true);expect(R instanceof spec.Country).toBe(true);expect(I.get("countryName")).toBe("USA");expect(R.get("countryName")).toBe("Canada");expect(J instanceof spec.City).toBe(true);expect(Q instanceof spec.City).toBe(true);expect(M instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(J.get("cityName")).toBe("Redwood City");expect(Q.get("cityName")).toBe("Frederick, MD");expect(M.get("cityName")).toBe("Vancouver");expect(P.get("cityName")).toBe("Toronto")})});describe("Filtering, and isLastVisible status",function(){var I,H,G;beforeEach(function(){A=Ext.create("Ext.data.TreeStore",{model:C,root:{expanded:true,id:0,name:"Root Node",children:[{name:"Foo"},{name:"Bar"},{name:"Bletch"}]}});I=A.getAt(0);H=A.getAt(1);G=A.getAt(2)});it("should correctly ascertain whether a node is the last visible node.",function(){expect(A.getCount()).toEqual(3);expect(I.isLastVisible()).toBe(false);expect(H.isLastVisible()).toBe(false);expect(G.isLastVisible()).toBe(true);A.filter({property:"name",value:"Foo"});expect(A.getCount()).toEqual(1);expect(I.isLastVisible()).toBe(true)})})});