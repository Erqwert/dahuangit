describe("Ext.data.schema.OneToOne",function(){var A,D,I,H,F,E;function C(J){D=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"addressId",unique:true,reference:Ext.apply({type:"Address"},J)}]});H=I.associations.user;F=D.associations.address;if(H){E=H.association}else{if(F){E=F.association}}}function G(K,J){Ext.Ajax.mockComplete({status:J||200,responseText:Ext.JSON.encode(K)})}beforeEach(function(){MockAjaxManager.addMethods();A=Ext.data.Model.schema;A.setNamespace("spec");I=Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","street","city","zip"]})});afterEach(function(){MockAjaxManager.removeMethods();Ext.undefine("spec.User");Ext.undefine("spec.Address");A.clear(true);E=D=H=I=F=A=null});describe("Model.associations",function(){it("should have an association role on each model",function(){C();expect(D.associations.address).toBeDefined();expect(I.associations.user).toBeDefined()});it("should have a reference back to the association for each role",function(){C();expect(I.associations.user.association).toBe(D.associations.address.association);expect(I.associations.user.association.isOneToOne).toBe(true)})});describe("association default config",function(){beforeEach(function(){C()});it("should have a schema set",function(){expect(E.schema).toBe(A)});it("should have the reference field set",function(){expect(E.field).toBe(D.getField("addressId"))});it("should have the left part be set to the key holder",function(){expect(E.left).toBe(H)});it("should set definedBy to the key holder",function(){expect(E.definedBy).toBe(D)});it("should have the right part be set to the non key holder",function(){expect(E.right).toBe(F)});it("should have the owner as null",function(){expect(E.owner).toBeNull()});it("should set the assoc name to {SingularRight}{SingularLeft}",function(){expect(E.name).toBe("AddressUser")})});describe("left",function(){beforeEach(function(){C()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(H.role).toBe("user");expect(H.type).toBe("User")});it("should set the inverse role to the right",function(){expect(H.inverse).toBe(F)});it("should set the entity",function(){expect(H.cls).toBe(D)})});describe("right",function(){beforeEach(function(){C()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(F.role).toBe("address");expect(F.type).toBe("Address")});it("should set the inverse role to the left",function(){expect(F.inverse).toBe(H)});it("should set the entity",function(){expect(F.cls).toBe(I)})});describe("configuring",function(){it("should set an association name",function(){C({association:"CustomName"});expect(E.name).toBe("CustomName")});it("should set the owner based on the child param",function(){C({child:true});expect(E.owner).toBe(H);expect(H.owner).toBe(true)});it("should set the owner based on the parent param",function(){C({parent:true});expect(E.owner).toBe(F);expect(F.owner).toBe(true)});it("should be able to set a custom role",function(){C({role:"foo"});F=D.associations.foo;E=F.association;expect(E.name).toBe("AddressFooUser");expect(F.role).toBe("foo")});describe("inverse",function(){it("should set with a string",function(){C({inverse:"foo"});expect(E.name).toBe("AddressFoo");H=I.associations.foo;expect(H.role).toBe("foo")});it("should set with an object",function(){C({inverse:{role:"foo"}});expect(E.name).toBe("AddressFoo");H=I.associations.foo;expect(H.role).toBe("foo")})})});describe("model decoration",function(){function J(K,L){expect(typeof K.prototype[L]).toBe("function")}it("should generate a getter on the key holder",function(){C();J(D,"getAddress")});it("should generate a setter on the key holder",function(){C();J(D,"setAddress")});it("should define a getter on the inverse",function(){C();J(I,"getUser")});it("should allow a custom getter name on the key holder",function(){C({getterName:"getCoolUser"});J(D,"getCoolUser")});it("should allow a custom setter name on the key holder",function(){C({setterName:"setCoolUser"});J(D,"setCoolUser")});it("should allow a custom getter name on the inverse",function(){C({inverse:{getterName:"getCoolAddress"}});J(I,"getCoolAddress")});it("should decorate the model based on the role",function(){Ext.define("spec.OtherUser",{extend:"Ext.data.Model",fields:["id","name",{name:"useralAddressId",reference:{type:"Address",role:"useralAddress"}},{name:"homeAddressId",reference:{type:"Address",role:"homeAddress"}}]});J(spec.OtherUser,"getUseralAddress");J(spec.OtherUser,"getHomeAddress");Ext.undefine("spec.OtherUser")})});describe("subclasing",function(){describe("the left",function(){var J;beforeEach(function(){C();J=Ext.define("spec.SubUser",{extend:"spec.User"})});it("should still have the original association",function(){var K=D.associations.address.inverse;expect(K.role).toBe("user");expect(K.cls).toBe(D)});it("should inherit the association from the parent and modify the relevant classes",function(){var K=J.associations.address.inverse;expect(K.role).toBe("subUser");expect(K.cls).toBe(J)})});describe("the right",function(){var J;beforeEach(function(){C();J=Ext.define("spec.SubAddress",{extend:"spec.Address"})});it("should not have any associations",function(){expect(J.associations).toEqual({})})})});function B(J){describe(J?"with session":"without session",function(){var K,N,L,M;beforeEach(function(){C();M=jasmine.createSpy();if(J){K=new Ext.data.Session()}});afterEach(function(){if(J){K.destroy()}K=M=N=L=null});describe("the key holder",function(){describe("getter",function(){beforeEach(function(){N=new D({id:4},K)});describe("without an instance",function(){describe("with no foreign key value",function(){it("should return null",function(){expect(N.getAddress()).toBeNull()});it("should not make any request",function(){M=spyOn(I.getProxy(),"read");N.getAddress();expect(M).not.toHaveBeenCalled()});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){N.getAddress(M);expect(M).toHaveBeenCalled();M.reset();N.getAddress({success:M});expect(M).toHaveBeenCalled();M.reset();N.getAddress({callback:M});expect(M).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){N.getAddress(M);var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept a function with a scope",function(){var O={};N.getAddress(M,O);expect(M.mostRecentCall.object).toBe(O)});it("should accept an options object with success and default the scope to the model",function(){N.getAddress({success:M});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.object).toBe(N)});it("should accept an options object with success and a scope",function(){var P={},O;N.getAddress({scope:P,success:M});O=M.mostRecentCall;expect(O.object).toBe(P)});it("should accept an options object with callback and default the scope to the model",function(){N.getAddress({callback:M});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var P={},O;N.getAddress({scope:P,callback:M});O=M.mostRecentCall;expect(O.object).toBe(P)})})});describe("with a foreign key value",function(){beforeEach(function(){N.set("addressId",17)});if(J){it("should create an instance in the session",function(){expect(N.getAddress()).toBe(K.getRecord("Address",17,false))});it("should use an existing record instance",function(){L=K.getRecord("Address",17,false);expect(N.getAddress()).toBe(L)});it("should not load an existing instance",function(){L=K.getRecord("Address",{id:17},false);N.getAddress();expect(L.isLoading()).toBe(false)})}it("should return an instance with the matching id",function(){expect(N.getAddress().getId()).toBe(17)});it("should be in a loading state",function(){expect(N.getAddress().isLoading()).toBe(true)});it("should trigger a load for the record",function(){M=spyOn(I.getProxy(),"read");N.getAddress();expect(M.mostRecentCall.args[0].getId()).toBe(17)});describe("calling while during a load",function(){it("should return the same record",function(){var O=N.getAddress();expect(N.getAddress()).toBe(O)});it("should not trigger a second load",function(){N.getAddress();M=spyOn(I.getProxy(),"read");N.getAddress();expect(M).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){N.getAddress();N.getAddress({success:M,callback:M});expect(M).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){N.getAddress();N.getAddress({success:M,callback:M});G({});expect(M.callCount).toBe(2)})});describe("callbacks",function(){it("should not trigger any callbacks until the load completes",function(){N.getAddress(M);N.getAddress({success:M});N.getAddress({failure:M});N.getAddress({callback:M});expect(M).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){L=N.getAddress(M);G({});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept a function with a scope",function(){var O={};N.getAddress(M,O);G({});expect(M.mostRecentCall.object).toBe(O)});it("should accept an options object with success and default the scope to the model",function(){L=N.getAddress({success:M});G({});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.object).toBe(N)});it("should accept an options object with success and a scope",function(){var P={},O;N.getAddress({scope:P,success:M});G({});O=M.mostRecentCall;expect(O.object).toBe(P)});it("should accept an options object with callback and default the scope to the model",function(){L=N.getAddress({callback:M});G({});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var P={},O;N.getAddress({scope:P,callback:M});G({});O=M.mostRecentCall;expect(O.object).toBe(P)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){L=N.getAddress(M);G(null,500);var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.args[2]).toBe(false);expect(O.object).toBe(N)});it("should accept a function with a scope",function(){var O={};N.getAddress(M,O);G(null,500);expect(M.mostRecentCall.object).toBe(O)});it("should accept an options object with failure and default the scope to the model",function(){L=N.getAddress({failure:M});G(null,500);var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.object).toBe(N)});it("should accept an options object with failure and a scope",function(){var P={},O;N.getAddress({scope:P,failure:M});G(null,500);O=M.mostRecentCall;expect(O.object).toBe(P)});it("should accept an options object with callback and default the scope to the model",function(){L=N.getAddress({callback:M});G(null,500);var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1].isOperation).toBe(true);expect(O.args[2]).toBe(false);expect(O.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var P={},O;N.getAddress({scope:P,callback:M});G(null,500);O=M.mostRecentCall;expect(O.object).toBe(P)})})})})});describe("with an already loaded instance",function(){beforeEach(function(){L=new I({id:2},K);N.setAddress(L)});it("should return the same instance",function(){expect(N.getAddress()).toBe(L)});it("should not attempt to load",function(){M=spyOn(I.getProxy(),"read");N.getAddress();expect(M).not.toHaveBeenCalled()});it("should attempt to reload if called with options.reload",function(){M=spyOn(I.getProxy(),"read").andReturn();N.getAddress({reload:true});expect(M).toHaveBeenCalled()});it("should reload the same record when called with reload",function(){var O=N.getAddress({reload:true});expect(O).toBe(L)});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){N.getAddress(M);expect(M).toHaveBeenCalled();M.reset();N.getAddress({success:M});expect(M).toHaveBeenCalled();M.reset();N.getAddress({callback:M});expect(M).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){N.getAddress(M);var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept a function with a scope",function(){var O={};N.getAddress(M,O);expect(M.mostRecentCall.object).toBe(O)});it("should accept an options object with success and default the scope to the model",function(){N.getAddress({success:M});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.object).toBe(N)});it("should accept an options object with success and a scope",function(){var P={},O;N.getAddress({scope:P,success:M});O=M.mostRecentCall;expect(O.object).toBe(P)});it("should accept an options object with callback and default the scope to the model",function(){N.getAddress({callback:M});var O=M.mostRecentCall;expect(O.args[0]).toBe(L);expect(O.args[1]).toBeNull();expect(O.args[2]).toBe(true);expect(O.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var P={},O;N.getAddress({scope:P,callback:M});O=M.mostRecentCall;expect(O.object).toBe(P)})})})});describe("setter",function(){beforeEach(function(){N=new D({id:7},K)});describe("instance",function(){var O;beforeEach(function(){O=new I({id:3},K);N.setAddress(O)});it("should have the same record reference",function(){expect(N.getAddress()).toBe(O)});it("should set the underlying key value",function(){expect(N.get("addressId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){N.setAddress(null);expect(N.getAddress()).toBeNull();expect(N.get("addressId")).toBeNull()})});describe("value",function(){it("should set the underlying key",function(){N.setAddress(16);expect(N.get("addressId")).toBe(16)});it("should keep the same reference if setting the value with a matching id",function(){var O=new I({id:3},K);N.setAddress(O);N.setAddress(3);expect(N.getAddress()).toBe(O)});it("should clear the reference if a model is already set and a new id is passed",function(){var O=new I({id:3},K);N.setAddress(O);N.setAddress(13);M=spyOn(I.getProxy(),"read");N.getAddress();expect(M.mostRecentCall.args[0].getId()).toBe(13)});it("should set the foreign key when setting to null",function(){N.setAddress(13);N.setAddress(null);expect(N.get("addressId")).toBeNull();M=spyOn(I.getProxy(),"read");N.getAddress();expect(M).not.toHaveBeenCalled()})});describe("callbacks",function(){it("should accept a function as the second arg, scope should default to the model",function(){N.setAddress(16,M);G({});var O=M.mostRecentCall;expect(O.args[0]).toBe(N);expect(O.object).toBe(N)});it("should accept a function with a scope",function(){var O={};L=N.setAddress(16,M,O);G({});expect(M.mostRecentCall.object).toBe(O)});describe("options object",function(){var P,O,Q;beforeEach(function(){P=jasmine.createSpy();O=jasmine.createSpy();Q=jasmine.createSpy()});afterEach(function(){P=O=Q=null});describe("on success",function(){it("should call success/callback and scope should default to the model",function(){N.setAddress(16,{success:P,callback:Q,failure:O});G({});expect(O).not.toHaveBeenCalled();expect(P).toHaveBeenCalled();expect(Q).toHaveBeenCalled();expect(P.mostRecentCall.object).toBe(N);expect(Q.mostRecentCall.object).toBe(N)});it("should use a passed scope",function(){var R={};N.setAddress(16,{scope:R,success:P,callback:Q});G({});expect(P.mostRecentCall.object).toBe(R);expect(Q.mostRecentCall.object).toBe(R)})});describe("on failure",function(){it("should call failure/callback and scope should default to the model",function(){N.setAddress(16,{success:P,callback:Q,failure:O});G(null,500);expect(P).not.toHaveBeenCalled();expect(O).toHaveBeenCalled();expect(Q).toHaveBeenCalled();expect(O.mostRecentCall.object).toBe(N);expect(Q.mostRecentCall.object).toBe(N)});it("should use a passed scope",function(){var R={};N.setAddress(16,{scope:R,failure:O,callback:Q});G(null,500);expect(O.mostRecentCall.object).toBe(R);expect(Q.mostRecentCall.object).toBe(R)})})})})});describe("modifying the foreign key",function(){var O;beforeEach(function(){O=new D({id:7},K)});it("should set the reference with no existing key",function(){O.set("addressId",44);expect(O.getAddress().getId()).toBe(44)});it("should clear the reference when setting to null",function(){L=new I({id:3},K);O.setAddress(L);O.set("addressId",null);expect(O.getAddress()).toBeNull()});it("should change the reference for the key",function(){L=new I({id:3},K);O.setAddress(L);O.set("addressId",123);expect(O.getAddress().getId()).toBe(123)})})})})}B(false);B(true)});