describe("Ext.data.schema.ManyToOne",function(){var A,B,D,G,E;function C(I){B=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"threadId",reference:Ext.apply({type:"Thread"},I)}]});G=B.associations.thread;E=D.associations.posts}function F(J,I){Ext.Ajax.mockComplete({status:I||200,responseText:Ext.JSON.encode(J)})}beforeEach(function(){MockAjaxManager.addMethods();A=Ext.data.Model.schema;A.setNamespace("spec");D=Ext.define("spec.Thread",{extend:"Ext.data.Model",fields:["id","title"]})});afterEach(function(){MockAjaxManager.removeMethods();Ext.undefine("spec.Post");Ext.undefine("spec.Thread");A.clear(true);B=E=D=G=A=null});describe("Model.associations",function(){it("should have an association role on each model",function(){C();expect(B.associations.thread).toBeDefined();expect(D.associations.posts).toBeDefined()});it("should have a reference back to the association for each role",function(){C();expect(B.associations.thread.association).toBe(D.associations.posts.association);expect(D.associations.posts.association.isManyToOne).toBe(true)})});describe("association default config",function(){var I;beforeEach(function(){C();I=G.association});it("should have a schema set",function(){expect(I.schema).toBe(A)});it("should have the reference field set",function(){expect(I.field).toBe(B.getField("threadId"))});it("should have the left part be set to the key holder",function(){expect(I.left).toBe(E)});it("should set definedBy to the key holder",function(){expect(I.definedBy).toBe(B)});it("should have the right part be set to the non key holder",function(){expect(I.right).toBe(G)});it("should have the owner as null",function(){expect(I.owner).toBeNull()});it("should set the assoc name to {PluralKeyHolder}By{SingluarOther}",function(){expect(I.name).toBe("ThreadPosts")})});describe("left",function(){beforeEach(function(){C()});it("should set the role to be plural lowercase & the type to be the entity name",function(){expect(E.role).toBe("posts");expect(E.type).toBe("Post")});it("should set the inverse role to the right",function(){expect(E.inverse).toBe(G)});it("should set the entity",function(){expect(E.cls).toBe(B)})});describe("right",function(){beforeEach(function(){C()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(G.role).toBe("thread");expect(G.type).toBe("Thread")});it("should set the inverse role to the left",function(){expect(G.inverse).toBe(E)});it("should set the entity",function(){expect(G.cls).toBe(D)})});describe("configuring",function(){it("should set an association name",function(){C({association:"CustomName"});expect(E.association.name).toBe("CustomName")});it("should set the owner based on the child param",function(){C({child:true});expect(E.association.owner).toBe(E);expect(E.owner).toBe(true)});it("should set the owner based on the parent param",function(){C({parent:true});expect(E.association.owner).toBe(G);expect(G.owner).toBe(true)});it("should be able to set a custom role",function(){C({role:"foo"});G=B.associations.foo;expect(G.association.name).toBe("ThreadFooPosts");expect(G.role).toBe("foo")});describe("inverse",function(){it("should set with a string",function(){C({inverse:"foo"});E=D.associations.foo;expect(E.association.name).toBe("ThreadFoo");expect(E.role).toBe("foo")});it("should set with an object",function(){C({inverse:{role:"foo"}});E=D.associations.foo;expect(E.association.name).toBe("ThreadFoo");expect(E.role).toBe("foo")})})});describe("model decoration",function(){it("should generate a getter on the key holder",function(){C();expect(typeof B.prototype.getThread).toBe("function")});it("should generate a setter on the key holder",function(){C();expect(typeof B.prototype.setThread).toBe("function")});it("should define a getter on the inverse",function(){C();expect(typeof D.prototype.posts).toBe("function")});it("should allow a custom getter name on the key holder",function(){C({inverse:{getterName:"getFoo"}});expect(typeof D.prototype.getFoo).toBe("function")});it("should allow a custom setter name on the key holder",function(){C({setterName:"setFoo"});expect(typeof B.prototype.setFoo).toBe("function")});it("should allow a custom getter name on the inverse",function(){C({getterName:"ghosts"});expect(typeof B.prototype.ghosts).toBe("function")});it("should decorate the model based on the role",function(){var I=Ext.define("spec.OtherPost",{extend:"Ext.data.Model",fields:["id","name",{name:"threadAId",reference:{type:"Thread",role:"ThreadA"}},{name:"threadBId",reference:{type:"Thread",role:"ThreadB"}}]});expect(typeof I.prototype.getThreadA).toBe("function");expect(typeof I.prototype.getThreadB).toBe("function");Ext.undefine("spec.OtherPost")})});describe("subclassing",function(){describe("the left",function(){var I;beforeEach(function(){C();I=Ext.define("spec.SubPost",{extend:"spec.Post"})});it("should still have the original association",function(){var J=B.associations.thread.inverse;expect(J.role).toBe("posts");expect(J.cls).toBe(B)});it("should inherit the association from the parent and modify the relevant classes",function(){var J=I.associations.thread.inverse;expect(J.role).toBe("subPosts");expect(J.cls).toBe(I)})});describe("the right",function(){var I;beforeEach(function(){C();I=Ext.define("spec.SubThread",{extend:"spec.Thread"})});it("should not have any associations",function(){expect(I.associations).toEqual({})})})});function H(I){describe(I?"with session":"without session",function(){var L,J,K,M;beforeEach(function(){L=jasmine.createSpy();if(I){J=new Ext.data.Session()}});afterEach(function(){if(I){J.destroy()}J=K=M=null});describe("the one",function(){beforeEach(function(){C()});describe("getter",function(){beforeEach(function(){K=new B({id:4},J)});describe("without an instance",function(){describe("with no foreign key value",function(){it("should return null",function(){expect(K.getThread()).toBeNull()});it("should not make any request",function(){L=spyOn(D.getProxy(),"read");K.getThread();expect(L).not.toHaveBeenCalled()});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){K.getThread(L);expect(L).toHaveBeenCalled();L.reset();K.getThread({success:L});expect(L).toHaveBeenCalled();L.reset();K.getThread({callback:L});expect(L).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){K.getThread(L);var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept a function with a scope",function(){var N={};K.getThread(L,N);expect(L.mostRecentCall.object).toBe(N)});it("should accept an options object with success and default the scope to the model",function(){K.getThread({success:L});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.object).toBe(K)});it("should accept an options object with success and a scope",function(){var O={},N;K.getThread({scope:O,success:L});N=L.mostRecentCall;expect(N.object).toBe(O)});it("should accept an options object with callback and default the scope to the model",function(){K.getThread({callback:L});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept an options object with callback and a scope",function(){var O={},N;K.getThread({scope:O,callback:L});N=L.mostRecentCall;expect(N.object).toBe(O)})})});describe("with a foreign key value",function(){beforeEach(function(){K.set("threadId",17)});if(I){it("should create an instance in the session",function(){expect(K.getThread()).toBe(J.getRecord("Thread",17,false))});it("should use an existing record instance",function(){M=J.getRecord("Thread",17,false);expect(K.getThread()).toBe(M)});it("should not load an existing instance",function(){M=J.getRecord("Thread",{id:17},false);K.getThread();expect(M.isLoading()).toBe(false)})}it("should return an instance with the matching id",function(){expect(K.getThread().getId()).toBe(17)});it("should be in a loading state",function(){expect(K.getThread().isLoading()).toBe(true)});it("should trigger a load for the record",function(){L=spyOn(D.getProxy(),"read");K.getThread();expect(L.mostRecentCall.args[0].getId()).toBe(17)});describe("calling while during a load",function(){it("should return the same record",function(){var N=K.getThread();expect(K.getThread()).toBe(N)});it("should not trigger a second load",function(){K.getThread();L=spyOn(D.getProxy(),"read");K.getThread();expect(L).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){K.getThread();K.getThread({success:L,callback:L});expect(L).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){K.getThread();K.getThread({success:L,callback:L});F({});expect(L.callCount).toBe(2)})});describe("callbacks",function(){it("should not trigger any callbacks until the load completes",function(){K.getThread(L);K.getThread({success:L});K.getThread({failure:L});K.getThread({callback:L});expect(L).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){M=K.getThread(L);F({});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept a function with a scope",function(){var N={};K.getThread(L,N);F({});expect(L.mostRecentCall.object).toBe(N)});it("should accept an options object with success and default the scope to the model",function(){M=K.getThread({success:L});F({});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.object).toBe(K)});it("should accept an options object with success and a scope",function(){var O={},N;K.getThread({scope:O,success:L});F({});N=L.mostRecentCall;expect(N.object).toBe(O)});it("should accept an options object with callback and default the scope to the model",function(){M=K.getThread({callback:L});F({});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept an options object with callback and a scope",function(){var O={},N;K.getThread({scope:O,callback:L});F({});N=L.mostRecentCall;expect(N.object).toBe(O)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){M=K.getThread(L);F(null,500);var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.args[2]).toBe(false);expect(N.object).toBe(K)});it("should accept a function with a scope",function(){var N={};K.getThread(L,N);F(null,500);expect(L.mostRecentCall.object).toBe(N)});it("should accept an options object with failure and default the scope to the model",function(){M=K.getThread({failure:L});F(null,500);var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.object).toBe(K)});it("should accept an options object with failure and a scope",function(){var O={},N;K.getThread({scope:O,failure:L});F(null,500);N=L.mostRecentCall;expect(N.object).toBe(O)});it("should accept an options object with callback and default the scope to the model",function(){M=K.getThread({callback:L});F(null,500);var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1].isOperation).toBe(true);expect(N.args[2]).toBe(false);expect(N.object).toBe(K)});it("should accept an options object with callback and a scope",function(){var O={},N;K.getThread({scope:O,callback:L});F(null,500);N=L.mostRecentCall;expect(N.object).toBe(O)})})})})});describe("with an already loaded instance",function(){beforeEach(function(){M=new D({id:2},J);K.setThread(M)});it("should return the same instance",function(){expect(K.getThread()).toBe(M)});it("should not attempt to load",function(){L=spyOn(D.getProxy(),"read");K.getThread();expect(L).not.toHaveBeenCalled()});it("should attempt to reload if called with options.reload",function(){L=spyOn(D.getProxy(),"read").andReturn();K.getThread({reload:true});expect(L).toHaveBeenCalled()});it("should reload the same record when called with reload",function(){var N=K.getThread({reload:true});expect(N).toBe(M)});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){K.getThread(L);expect(L).toHaveBeenCalled();L.reset();K.getThread({success:L});expect(L).toHaveBeenCalled();L.reset();K.getThread({callback:L});expect(L).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){K.getThread(L);var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept a function with a scope",function(){var N={};K.getThread(L,N);expect(L.mostRecentCall.object).toBe(N)});it("should accept an options object with success and default the scope to the model",function(){K.getThread({success:L});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.object).toBe(K)});it("should accept an options object with success and a scope",function(){var O={},N;K.getThread({scope:O,success:L});N=L.mostRecentCall;expect(N.object).toBe(O)});it("should accept an options object with callback and default the scope to the model",function(){K.getThread({callback:L});var N=L.mostRecentCall;expect(N.args[0]).toBe(M);expect(N.args[1]).toBeNull();expect(N.args[2]).toBe(true);expect(N.object).toBe(K)});it("should accept an options object with callback and a scope",function(){var O={},N;K.getThread({scope:O,callback:L});N=L.mostRecentCall;expect(N.object).toBe(O)})})})});describe("setter",function(){beforeEach(function(){K=new B({id:7},J)});describe("instance",function(){var N;beforeEach(function(){N=new D({id:3});K.setThread(N)});it("should have the same record reference",function(){expect(K.getThread()).toBe(N)});it("should set the underlying key value",function(){expect(K.get("threadId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){K.setThread(null);expect(K.getThread()).toBeNull();expect(K.get("threadId")).toBeNull()})});describe("value",function(){it("should set the underlying key",function(){K.setThread(16);expect(K.get("threadId")).toBe(16)});it("should keep the same reference if setting the value with a matching id",function(){var N=new D({id:3},J);K.setThread(N);K.setThread(3);expect(K.getThread()).toBe(N)});it("should clear the reference if a model is already set and a new id is passed",function(){var N=new D({id:3},J);K.setThread(N);K.setThread(13);L=spyOn(D.getProxy(),"read");K.getThread();expect(L.mostRecentCall.args[0].getId()).toBe(13)});it("should set the foreign key when setting to null",function(){K.setThread(13);K.setThread(null);expect(K.get("threadId")).toBeNull();L=spyOn(D.getProxy(),"read");K.getThread();expect(L).not.toHaveBeenCalled()})});describe("callbacks",function(){it("should accept a function as the second arg, scope should default to the model",function(){K.setThread(16,L);F({});var N=L.mostRecentCall;expect(N.args[0]).toBe(K);expect(N.object).toBe(K)});it("should accept a function with a scope",function(){var N={};M=K.setThread(16,L,N);F({});expect(L.mostRecentCall.object).toBe(N)});describe("options object",function(){var O,N,P;beforeEach(function(){O=jasmine.createSpy();N=jasmine.createSpy();P=jasmine.createSpy()});afterEach(function(){O=N=P=null});describe("on success",function(){it("should call success/callback and scope should default to the model",function(){K.setThread(16,{success:O,callback:P,failure:N});F({});expect(N).not.toHaveBeenCalled();expect(O).toHaveBeenCalled();expect(P).toHaveBeenCalled();expect(O.mostRecentCall.object).toBe(K);expect(P.mostRecentCall.object).toBe(K)});it("should use a passed scope",function(){var Q={};K.setThread(16,{scope:Q,success:O,callback:P});F({});expect(O.mostRecentCall.object).toBe(Q);expect(P.mostRecentCall.object).toBe(Q)})});describe("on failure",function(){it("should call failure/callback and scope should default to the model",function(){K.setThread(16,{success:O,callback:P,failure:N});F(null,500);expect(O).not.toHaveBeenCalled();expect(N).toHaveBeenCalled();expect(P).toHaveBeenCalled();expect(N.mostRecentCall.object).toBe(K);expect(P.mostRecentCall.object).toBe(K)});it("should use a passed scope",function(){var Q={};K.setThread(16,{scope:Q,failure:N,callback:P});F(null,500);expect(N.mostRecentCall.object).toBe(Q);expect(P.mostRecentCall.object).toBe(Q)})})})})});describe("modifying the foreign key",function(){var P,N;beforeEach(function(){P=new D({id:1},J);N=P.posts()});function O(R,Q){K=new B({id:R,threadId:Q||1},J)}afterEach(function(){N=P=null});it("should remove from the store when changing the key to null",function(){O(101);N.add(K);K.set("threadId",null);expect(N.getCount()).toBe(0)});it("should remove from the store when changing the key to some other value",function(){O(101);N.add(K);K.set("threadId",4);expect(N.getCount()).toBe(0)});it("should not remove the record from unrelated stores",function(){O(101);var Q=new Ext.data.Store();Q.add(K);N.add(K);K.set("threadId",null);expect(N.getCount()).toBe(0);expect(Q.first()).toBe(K);Q.destroy()});if(I){it("should add to an existing store if a matching key is found",function(){var Q=new D({id:2},J);var R=Q.posts();O(101);N.add(K);K.set("threadId",2);expect(N.getCount()).toBe(0);expect(R.first()).toBe(K)});it("should not create the record if the existing key does not exist",function(){O(101);N.add(K);K.set("threadId",2);expect(J.peekRecord("Thread",2)).toBeNull()});it("should not create the store on an existing record",function(){var Q=new D({id:2},J);var R=Q.associations.posts.getStoreName();O(101);N.add(K);K.set("threadId",2);expect(Q[R]).toBeUndefined()});it("should not add if an existing store is loading",function(){var Q=new D({id:2},J);var R=Q.posts();R.load();O(101);N.add(K);K.set("threadId",2);expect(N.getCount()).toBe(0);expect(R.getCount()).toBe(0)})}})});describe("the many",function(){var P;function O(){N=new D({id:3},J)}var N;afterEach(function(){P=N=null});it("should return a store",function(){C();O();expect(N.posts().isStore).toBe(true)});it("should set the appropriate model type",function(){C();O();expect(N.posts().model).toBe(B)});if(I){it("should set the session on the store",function(){C();O();expect(N.posts().getSession()).toBe(J)})}it("should return the same store instance on multiple calls",function(){C();O();var Q=N.posts();expect(N.posts()).toBe(Q)});it("should apply the storeConfig",function(){C({inverse:{storeConfig:{autoLoad:true}}});O();P=N.posts();expect(P.getAutoLoad()).toBe(true);P.destroy()});it("should add a filter on the store",function(){C();O();var Q=N.posts(),R=Q.getFilters().first();expect(R.getProperty()).toBe("threadId");expect(R.getValue()).toBe(3)});describe("autoLoad",function(){it("should not load the store by default",function(){C();O();var Q=spyOn(Ext.data.Store.prototype,"load").andReturn();N.posts();expect(Q.callCount).toBe(0)});it("should load the store if configured with autoLoad: true",function(){C({inverse:{autoLoad:true}});O();var Q=spyOn(Ext.data.Store.prototype,"load").andReturn();N.posts();expect(Q.callCount).toBe(1)})});describe("store modification",function(){beforeEach(function(){C();O()});describe("adding",function(){it("should default to the key to the primaryKey",function(){var R=N.posts(),Q;R.load();F([]);Q=R.add({})[0];expect(Q.get("threadId")).toBe(3)});it("should set the primaryKey onto the foreignKey on add",function(){var R=N.posts(),Q;R.load();F([]);Q=R.add({threadId:1})[0];expect(Q.get("threadId")).toBe(3)})});describe("removing",function(){it("should set the key to null when removing an item",function(){var R=N.posts(),Q;R.load();F([{id:12,threadId:3}]);Q=R.first();R.remove(Q);expect(Q.get("threadId")).toBeNull()});it("should set the key to null when removing all items",function(){var S=N.posts(),R,Q,T;S.load();F([{id:11,threadId:3},{id:12,threadId:3},{id:13,threadId:3}]);R=S.getAt(0);Q=S.getAt(1);T=S.getAt(2);S.removeAll();expect(R.get("threadId")).toBeNull();expect(Q.get("threadId")).toBeNull();expect(T.get("threadId")).toBeNull()})})});describe("reload",function(){beforeEach(function(){C();O()});it("should reload an existing store",function(){N.posts();L=spyOn(B.getProxy(),"read");N.posts({reload:true});expect(L).toHaveBeenCalled()});it("should not trigger an existing load if already loading",function(){P=N.posts({});expect(P.isLoading()).toBe(true);L=spyOn(B.getProxy(),"read");N.posts({reload:true});expect(L).not.toHaveBeenCalled()})});describe("calling while during a load",function(){beforeEach(function(){C();O()});it("should not trigger a second load",function(){N.posts({});L=spyOn(B.getProxy(),"read");N.posts({});expect(L).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){N.posts({});N.posts({success:L,callback:L});expect(L).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){N.posts({});N.posts({success:L,callback:L});F([]);expect(L.callCount).toBe(2)})});describe("callbacks",function(){beforeEach(function(){C();O()});describe("when not triggering a load",function(){beforeEach(function(){N.posts()});it("should call the callbacks before the function returns",function(){N.posts(L);expect(L).toHaveBeenCalled();L.reset();N.posts({success:L});expect(L).toHaveBeenCalled();L.reset();N.posts({callback:L});expect(L).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){P=N.posts(L);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.posts(L,Q);expect(L.mostRecentCall.object).toBe(Q)});it("should accept an options object with success and default the scope to the model",function(){P=N.posts({success:L});var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1]).toBeNull();expect(Q.object).toBe(N)});it("should accept an options object with success and a scope",function(){var R={},Q;N.posts({scope:R,success:L});Q=L.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){P=N.posts({callback:L});var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.posts({scope:R,callback:L});Q=L.mostRecentCall;expect(Q.object).toBe(R)})});describe("when triggering a load",function(){it("should not trigger any callbacks until the load completes",function(){N.posts(L);N.posts({success:L});N.posts({failure:L});N.posts({callback:L});expect(L).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){P=N.posts(L);F([]);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.posts(L,Q);F([]);expect(L.mostRecentCall.object).toBe(Q)});it("should accept an options object with success and default the scope to the model",function(){P=N.posts({success:L});F([]);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with success and a scope",function(){var R={},Q;N.posts({scope:R,success:L});F([]);Q=L.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){P=N.posts({callback:L});F([]);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.posts({scope:R,callback:L});F([]);Q=L.mostRecentCall;expect(Q.object).toBe(R)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){P=N.posts(L);F(null,500);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(false);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.posts(L,Q);F(null,500);expect(L.mostRecentCall.object).toBe(Q)});it("should accept an options object with failure and default the scope to the model",function(){P=N.posts({failure:L});F(null,500);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with failure and a scope",function(){var R={},Q;N.posts({scope:R,failure:L});F(null,500);Q=L.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){P=N.posts({callback:L});F(null,500);var Q=L.mostRecentCall;expect(Q.args[0]).toBe(P);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(false);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.posts({scope:R,callback:L});F(null,500);Q=L.mostRecentCall;expect(Q.object).toBe(R)})})})});if(I){describe("local store modifications with loading",function(){var Q;beforeEach(function(){C();O();P=N.posts();Q=[{id:101,threadId:3},{id:102,threadId:3},{id:103,threadId:3}]});it("should exclude records with local foreign key changes",function(){P.load();F(Q);var R=J.getRecord("Post",102);P.removeAt(1);expect(R.get("threadId")).toBeNull();P.load();F(Q);expect(P.getCount()).toBe(2);expect(P.indexOf(R)).toBe(-1)});it("should append records with the key that were not attached",function(){P.load();F(Q);var R=J.getRecord("Post",104);F({id:104});P.add(R);expect(R.get("threadId")).toBe(3);P.load();F(Q);expect(P.getCount()).toBe(4);expect(P.indexOf(R)).toBe(3)})})}})})}H(false);H(true)});