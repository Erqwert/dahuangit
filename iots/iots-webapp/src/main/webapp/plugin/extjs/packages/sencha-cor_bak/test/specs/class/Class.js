describe("Ext.Class",function(){var B=function(){},G=function(K){this.initConfig(K)},E,I,F,C,A,D,J,H;beforeEach(function(){F=function(){};D=Ext.define(null,{config:{mixinConfig:"mixinConfig"},constructor:function(K){this.initConfig(K);this.mixinConstructor1Called=true},mixinProperty1:"mixinProperty1",mixinMethod1:function(){this.mixinMethodCalled=true}});J=Ext.define(null,{constructor:function(K){this.initConfig(K);this.mixinConstructor2Called=true},mixinProperty2:"mixinProperty2",mixinMethod2:function(){this.mixinMethodCalled=true}});A=Ext.define(null,{mixins:{mixin1:D},config:{name:"parentClass",isCool:false,members:{abe:"Abraham Elias",ed:"Ed Spencer"},hobbies:["football","bowling"]},constructor:function(K){this.initConfig(K);this.parentConstructorCalled=true;this.mixins.mixin1.constructor.apply(this,arguments)},parentProperty:"parentProperty",parentMethod:function(){this.parentMethodCalled=true}});C=Ext.define(null,{extend:A,mixins:{mixin1:D,mixin2:J},config:{name:"subClass",isCool:true,members:{jacky:"Jacky Nguyen",tommy:"Tommy Maintz"},hobbies:["sleeping","eating","movies"],isSpecial:true},constructor:function(K){this.initConfig(K);this.subConstructorCalled=true;C.superclass.constructor.apply(this,arguments);this.mixins.mixin2.constructor.apply(this,arguments)},myOwnMethod:function(){this.myOwnMethodCalled=true}})});afterEach(function(){H=C,A,D,J=I=E=null});describe("extend",function(){beforeEach(function(){F=function(){};Ext.define("spec.Base",{aProp:1,aFn:F})});afterEach(function(){Ext.undefine("spec.Base")});it("should extend from Base if no 'extend' property found",function(){E=Ext.define(null,{});expect((new E()) instanceof Ext.Base).toBe(true)});describe("extending from a parent",function(){it("class reference",function(){E=Ext.define(null,{extend:spec.Base});expect((new E()) instanceof spec.Base).toBe(true)});it("class string",function(){E=Ext.define(null,{extend:"spec.Base"});expect((new E()) instanceof spec.Base).toBe(true)})});it("should have superclass reference",function(){var K=spec.Base.prototype;E=Ext.define(null,{extend:spec.Base});expect(E.superclass).toBe(K);expect((new E()).superclass).toBe(K)});it("should copy properties from the parent",function(){E=Ext.define(null,{extend:spec.Base});expect(E.prototype.aProp).toBe(1)});it("should copy functions from the parent",function(){E=Ext.define(null,{extend:spec.Base});expect(E.prototype.aFn).toBe(F)})});describe("config",function(){beforeEach(function(){F=function(){}});describe("getter/setter creation",function(){it("should create getter if not exists",function(){E=Ext.define(null,{config:{someName:"someValue"}});expect(E.prototype.getSomeName).toBeDefined()});it("should NOT create getter if already exists",function(){var K=Ext.define(null,{getSomeName:F,config:{someName:"someValue"}});expect(K.prototype.getSomeName).toBe(F)});it("should create setter if not exists",function(){E=Ext.define(null,{config:{someName:"someValue"}});expect(E.prototype.setSomeName).toBeDefined()});it("should NOT create setter if already exists",function(){E=Ext.define(null,{setSomeName:F,config:{someName:"someValue"}});expect(E.prototype.setSomeName).toBe(F)});it("should allow a custom getter to call the generated getter",function(){E=Ext.define(null,{config:{someName:"foo"},constructor:G,getSomeName:function(){return this.callParent().toUpperCase()}});H=new E();expect(H.getSomeName()).toBe("FOO")});it("should allow a custom setter to call the generated setter",function(){E=Ext.define(null,{config:{someName:"foo"},constructor:G,setSomeName:function(K){K=K.toUpperCase();return this.callParent([K])}});H=new E();expect(H.getSomeName()).toBe("FOO")});it("should not set the value if the applier returns undefined",function(){var K=false;E=Ext.define(null,{config:{foo:1},constructor:G,applyFoo:function(L){if(!K){K=true;return L}return undefined}});H=new E();H.setFoo(2);expect(H.getFoo()).toBe(1)});it("should not call the updater if the value does not change",function(){var K=0;E=Ext.define(null,{config:{foo:1},constructor:G,updateFoo:function(){++K}});H=new E();H.setFoo(1);expect(K).toBe(1)});it("should check using === to see if the value changed",function(){var K=0;E=Ext.define(null,{config:{foo:1},constructor:G,updateFoo:function(){++K}});H=new E();H.setFoo("1");expect(K).toBe(2)});describe("when getters are called by other configs' updaters",function(){var L,K;beforeEach(function(){E=Ext.define(null,{config:{foo:1,bar:2},constructor:G,updateFoo:function(){this.getBar()},applyBar:function(M){++L;return M},updateBar:function(){++K}})});it("should only call appliers/updaters once for class configs",function(){L=K=0;H=new E();expect(L).toBe(1);expect(K).toBe(1)});it("should only call appliers/updaters once for instance configs",function(){L=K=0;H=new E({foo:10,bar:20});expect(L).toBe(1);expect(K).toBe(1)})});describe("initialization",function(){describe("default values - no passed config",function(){describe("null",function(){it("should not initialize the config",function(){E=Ext.define(null,{config:{foo:null},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});H=new E();expect(H.setFoo).not.toHaveBeenCalled()});it("should not initialize with a custom setter",function(){var K=false;E=Ext.define(null,{config:{foo:null},constructor:G,setFoo:function(){K=true}});H=new E();expect(K).toBe(false)});it("should not initialize with an applier",function(){var K=false;E=Ext.define(null,{config:{foo:null},constructor:G,applyFoo:function(){K=true}});H=new E();expect(K).toBe(false)});it("should not initialize with an updater",function(){var K=false;E=Ext.define(null,{config:{foo:null},constructor:G,updateFoo:function(){K=true}});H=new E();expect(K).toBe(false)})});describe("other values",function(){it("should not call the setter",function(){E=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});H=new E();expect(H.setFoo).not.toHaveBeenCalled()});it("should call the setter if there is a custom setter",function(){E=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},setFoo:function(){}});H=new E();expect(H.setFoo).toHaveBeenCalled()});it("should call the setter if there is an applier",function(){E=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},applyFoo:function(K){return K}});H=new E();expect(H.setFoo).toHaveBeenCalled()});it("should call the setter if there is an updater",function(){E=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},setFoo:function(){}});H=new E();expect(H.setFoo).toHaveBeenCalled()});it("should call the setter if the value is an object",function(){E=Ext.define(null,{config:{foo:{}},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});H=new E();expect(H.setFoo).toHaveBeenCalled()})})});describe("dependencies",function(){it("should force an initialization if the getter is called during init time for a primitive",function(){var K;E=Ext.define(null,{config:{first:undefined,second:undefined},constructor:G,updateFirst:function(){K=this.getSecond()}});new E({first:1,second:2});expect(K).toBe(2)});it("should have a non-config applied by the time any setter is called with non-strict mode",function(){var K;E=Ext.define(null,{config:{first:undefined},constructor:G,$configStrict:false,applyFirst:function(){K=this.second}});new E({first:1,second:2});expect(K).toBe(2)})})})});describe("get/setConfig",function(){beforeEach(function(){E=Ext.define(null,{config:{foo:1,bar:2},constructor:G})});describe("dependency ordering",function(){var K;function L(){K=[];E=Ext.define(null,{config:{b:"bbb",c:"ccc",a:"aaa"},constructor:G,applyA:function(M){K.push("a="+M)},applyB:function(M){this.getA();K.push("b="+M)},applyC:function(M){this.getB();K.push("c="+M)}})}it("should initialize dependent config first",function(){L();var M=new E();expect(K).toEqual(["a=aaa","b=bbb","c=ccc"])});it("should update configs in dependency order",function(){L();var M=new E();K.length=0;M.setConfig({a:1,c:3,b:2});expect(K).toEqual(["a=1","b=2","c=3"])})});describe("getConfig",function(){it("should be able to get a config by name",function(){H=new E();expect(H.getConfig("bar")).toBe(2)});it("should return all configs if no name is passed",function(){H=new E();expect(H.getConfig()).toEqual({foo:1,bar:2})});it("should throw an exception when asking for a config name that does not exist",function(){H=new E();expect(function(){H.getConfig("fake")}).toThrow()});describe("peek",function(){beforeEach(function(){E=Ext.define(null,{constructor:G,config:{foo:{lazy:true,$value:120}}})});it("should not call the getter if the initGetter has not yet been called",function(){H=new E({foo:1});spyOn(H,"getFoo");H.getConfig("foo",true);expect(H.getFoo).not.toHaveBeenCalled()});it("should return the pending value configured on the instance",function(){H=new E({foo:1});expect(H.getConfig("foo",true)).toBe(1)});it("should return the pending value configured on the class",function(){H=new E();expect(H.getConfig("foo",true)).toBe(120)})})});describe("setConfig",function(){it("should be able to set a config by name",function(){H=new E();H.setConfig("foo",7);expect(H.getFoo()).toBe(7)});it("should be able to set a group of configs at once",function(){H=new E();H.setConfig({foo:6,bar:8});expect(H.getFoo()).toBe(6);expect(H.getBar()).toBe(8)});it("should ignore non-config properties",function(){H=new E();expect(function(){H.setConfig({foo:3,baz:100})}).not.toThrow()});it("should throw an exception when setting a config name that does not exist",function(){H=new E();expect(function(){H.setConfig("baz",100)}).toThrow()});it("should be able to handle undefined/null configs",function(){H=new E();expect(function(){H.setConfig(null);H.setConfig(undefined)}).not.toThrow()});it("should return the current instance",function(){H=new E();expect(H.setConfig()).toBe(H)})})});it("should merge properly",function(){var K=new C;expect(K.config).toEqual({mixinConfig:"mixinConfig",name:"subClass",isCool:true,members:{abe:"Abraham Elias",ed:"Ed Spencer",jacky:"Jacky Nguyen",tommy:"Tommy Maintz"},hobbies:["sleeping","eating","movies"],isSpecial:true})});it("should apply default config",function(){var K=new C;expect(K.getName()).toBe("subClass");expect(K.getIsCool()).toBe(true);expect(K.getHobbies()).toEqual(["sleeping","eating","movies"])});it("should apply with supplied config",function(){var K=new C({name:"newName",isCool:false,members:{aaron:"Aaron Conran"}});expect(K.getName()).toBe("newName");expect(K.getIsCool()).toBe(false);expect(K.getMembers().aaron).toBe("Aaron Conran")});it("should not share the same config",function(){var K=new C({name:"newName",isCool:false,members:{aaron:"Aaron Conran"}});var L=new C();expect(L.getName()).not.toBe("newName")});it("should copy objects",function(){var K=new A(),M=new A(),L=K.getMembers(),N=M.getMembers();expect(L).not.toBe(N);expect(L).toEqual(N)});it("should copy arrays",function(){var M=new A(),N=new A(),L=M.getHobbies(),K=N.getHobbies();expect(L).not.toBe(K);expect(L).toEqual(K)});describe("values",function(){it("should set the the config value defined",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});expect((new E()).getFoo()).toBe("bar")});it("should be able to set the config",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});H=new E();H.setFoo("baz");expect(H.getFoo()).toBe("baz");H=null});it("should use the inherited config",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});I=Ext.define(null,{extend:E,config:{foo:"baz"}});expect((new I()).getFoo()).toBe("baz")});it("should inherit the parent value even if not specified in the config block",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});I=Ext.define(null,{extend:E,config:{herp:"derp"}});expect((new I()).getFoo()).toBe("bar")})});describe("value on prototype",function(){it("should read the value from the prototype in a subclass",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});I=Ext.define(null,{extend:E,foo:"baz"});expect((new I()).getFoo()).toBe("baz")});it("should remove the property from the prototype",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});I=Ext.define(null,{extend:E,foo:"baz"});expect(I.prototype.foo).toBeUndefined()});it("should favour the property on the config",function(){E=Ext.define(null,{constructor:G,foo:"baz",config:{foo:"bar"}});expect((new E()).getFoo()).toBe("bar")});it("should favour the property on the prototype in a subclass",function(){E=Ext.define(null,{constructor:G,config:{foo:"bar"}});I=Ext.define(null,{extend:E,foo:"baz"});expect((new I()).getFoo()).toBe("baz")});it("should pull the property from the prototype in the subclass if it exists on the parent prototype",function(){E=Ext.define(null,{constructor:G,foo:"baz",config:{foo:"bar"}});I=Ext.define(null,{extend:E,foo:"bleh"});expect((new I()).getFoo()).toBe("bleh")})});describe("$configStrict",function(){it("should not copy non-configs to the instance when true",function(){E=Ext.define(null,{$configStrict:true,config:{foo:"bar"},constructor:G});H=new E({baz:1});expect(H.baz).not.toBeDefined()});it("should copy non-configs to the instance when false",function(){E=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:G});H=new E({baz:1});expect(H.baz).toBe(1)});it("should not copy if the subclass sets the property to true",function(){E=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:G});I=Ext.define(null,{extend:I,$configStrict:true});H=new I({baz:1});expect(H.baz).not.toBeDefined()})});describe("$configPrefixed",function(){var K=function(L,M){E=Ext.define(null,{$configPrefixed:!!L,config:{foo:M||"bar"},constructor:G})};it("should use the config name as the instance property when false",function(){K();H=new E();expect(H.foo).toBe("bar")});it("should use _config name as the instance property when true",function(){K(true);H=new E();expect(H._foo).toBe("bar")});it("should allow a subclass to have a different prefix",function(){K(false,{});I=Ext.define(null,{extend:E,$configPrefixed:true});var L=new E(),M=new I();expect(L.foo).toEqual({});expect(M._foo).toEqual({});expect(M.foo).not.toBeDefined()})});describe("meta configs",function(){describe("mixins",function(){it("should inherit meta configs from mixins",function(){var K=0;var N=Ext.define(null,{config:{foo:{lazy:true,$value:42}}});var L=Ext.define(null,{mixins:{mix:N},constructor:function(O){this.initConfig(O)},applyFoo:function(P,O){++K;return P}});H=new L();expect(K).toBe(0);var M=H.getFoo();expect(M).toBe(42);expect(K).toBe(1)});it("should not allow mixins to modify meta configs",function(){var K=0;var N=Ext.define(null,{config:{foo:{lazy:false,$value:1}}});var L=Ext.define(null,{mixins:{mix:N},config:{foo:{lazy:true,$value:2}},constructor:function(O){this.initConfig(O)},applyFoo:function(P,O){++K;return P}});H=new L();expect(K).toBe(0);var M=H.getFoo();expect(M).toBe(2);expect(K).toBe(1)})});describe("cached",function(){describe("caching",function(){it("should not attempt to initialize until the first instance",function(){E=Ext.define(null,{config:{foo:{cached:true,$value:"bar"}}});expect(E.prototype.foo).not.toBeDefined()});it("should not attempt to cache the config if we don't call initConfig",function(){E=Ext.define(null,{config:{foo:{cached:true,$value:"bar"}}});new E();expect(E.prototype.foo).not.toBeDefined()});it("should stamp the value on the prototype after the first instance is created",function(){E=Ext.define(null,{constructor:G,cachedConfig:{foo:"bar"}});H=new E();expect(E.prototype._foo).toBe("bar");expect(H.hasOwnProperty("_foo")).toBe(false)});it("should stamp all values on the prototype after the first instance is created",function(){var K=0;E=Ext.define(null,{constructor:G,cachedConfig:{foo:21,bar:1,baz:3},applyFoo:function(L){++K;return L*this.getBar()},applyBar:function(L){++K;return L*2},applyBaz:function(L){++K;return L*this.getFoo()}});H=new E();expect(E.prototype._foo).toBe(42);expect(E.prototype._bar).toBe(2);expect(E.prototype._baz).toBe(3*42);expect(K).toBe(3);expect(H.hasOwnProperty("_foo")).toBe(false);expect(H.hasOwnProperty("_bar")).toBe(false);expect(H.hasOwnProperty("_baz")).toBe(false);H=new E();expect(K).toBe(3);expect(H.hasOwnProperty("_foo")).toBe(false);expect(H.hasOwnProperty("_bar")).toBe(false);expect(H.hasOwnProperty("_baz")).toBe(false)});it("should work with the cachedConfig notification",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});H=new E();expect(E.prototype._foo).toBe("bar");expect(H.hasOwnProperty("_foo")).toBe(false)});it("should call an applier only once",function(){var K=0;H={};E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}},applyFoo:function(O){++K;H.foo=O;return H}});var N=new E(),L=new E(),M=new E();expect(K).toBe(1);expect(N.getFoo()).toBe(H);expect(L.getFoo()).toBe(H);expect(M.getFoo()).toBe(H)});it("should call the updater only once",function(){var K=0;E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}},updateFoo:function(O){++K}});var N=new E(),L=new E(),M=new E();expect(K).toBe(1)});it("should allow the value to be updated from the config",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});H=new E({foo:"baz"});expect(E.prototype._foo).toBe("bar");expect(H.getFoo()).toBe("baz")});it("should allow the value to be updated from the setter",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});H=new E();H.setFoo("baz");expect(E.prototype._foo).toBe("bar");expect(H.getFoo()).toBe("baz")})});describe("subclassing",function(){it("should initialize the value on the subclass prototype",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});I=Ext.define(null,{extend:E});H=new I();expect(I.prototype._foo).toBe("bar");expect(H.getFoo()).toBe("bar")});it("should be able to override the default value",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});I=Ext.define(null,{extend:E,config:{foo:{cached:true,$value:"baz"}}});H=new I();expect(I.prototype._foo).toBe("baz");expect(H.getFoo()).toBe("baz")});it("should call the applier only once per instance",function(){var K=0,L=0;E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}},applyFoo:function(M){if(this.self===E){++K}else{if(this.self===I){++L}}return M}});I=Ext.define(null,{extend:E});new E();new I();new E();new I();new E();new I();expect(K).toBe(1);expect(L).toBe(1)});it("should retain cached-ness even when overridden in a subclass config",function(){E=Ext.define(null,{constructor:G,config:{foo:{cached:true,$value:"bar"}}});I=Ext.define(null,{config:{foo:"baz"}})});it("should not allow an initially uncached config to be declared as cached",function(){E=Ext.define(null,{config:{foo:1}});expect(function(){Ext.define(null,{extend:E,config:{foo:{cached:true,$value:2}}})}).toThrow()});describe("nulls",function(){it("should allow null overrides in child classes",function(){E=Ext.define(null,{config:{foo:{cached:true,$value:1}},constructor:G});I=Ext.define(null,{extend:E,config:{foo:{cached:true,$value:null}}});new E();new I();expect(E.prototype._foo).toBe(1);expect(I.prototype._foo).not.toBeDefined()});it("should allow null in the base class and value overrides in child classes",function(){E=Ext.define(null,{config:{foo:{cached:true,$value:null}},constructor:G});I=Ext.define(null,{extend:E,config:{foo:{cached:true,$value:1}}});new E();new I();expect(E.prototype._foo).toBe(null);expect(I.prototype._foo).toBe(1)});it("should be able to return to being cached after being nulled out",function(){var M=Ext.define(null,{config:{foo:{cached:true,$value:1}},constructor:G});var K=Ext.define(null,{extend:M,config:{foo:{cached:true,$value:null}}});var L=Ext.define(null,{extend:K,config:{foo:{cached:true,$value:2}}});new M();expect(M.prototype._foo).toBe(1);new K();expect(K.prototype._foo).not.toBeDefined();new L();expect(L.prototype._foo).toBe(2)})})})});describe("lazy",function(){function K(L){return{foo:{lazy:true,$value:L}}}describe("basic construction",function(){it("should not call the applier when instantiated without a config value",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});new L();expect(M).not.toHaveBeenCalled()});it("should not call the applier when instantiated with a config value",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});new L({foo:100});expect(M).not.toHaveBeenCalled()});it("should not call the updater when instantiated without a config value",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),updateFoo:M});new L();expect(M).not.toHaveBeenCalled()});it("should not call the updater when instantiated with a config value",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),updateFoo:M});new L({foo:100});expect(M).not.toHaveBeenCalled()})});describe("during construction",function(){it("should allow the getter to be called during initConfig by another method",function(){var L=Ext.define(null,{constructor:G,config:Ext.apply({bar:0},K(1)),applyBar:function(){return this.getFoo()+100}});H=new L();expect(H.getBar()).toBe(101)});it("should not call the applier on subsequent get calls",function(){var M=jasmine.createSpy().andReturn(1);var L=Ext.define(null,{constructor:G,config:Ext.apply({bar:0},K(1)),applyFoo:M,applyBar:function(){return this.getFoo()+100}});H=new L();expect(M.callCount).toBe(1);H.getFoo();expect(M.callCount).toBe(1)});it("should not call the updater on subsequent get calls",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:Ext.apply({bar:0},K(1)),updateFoo:M,applyBar:function(){return this.getFoo()+100}});H=new L();expect(M.callCount).toBe(1);H.getFoo();expect(M.callCount).toBe(1)})});describe("value before first get call",function(){describe("from the prototype",function(){it("should have primitives defined on the instance",function(){var L=Ext.define(null,{constructor:G,config:K(1)});var M=new L();expect(M._foo).toBe(1)});it("should not have objects on the instance",function(){var L=Ext.define(null,{constructor:G,config:K({})});var M=new L();expect(M._foo).not.toBeDefined()})});describe("from the instance config",function(){it("should not set the value on the underlying property",function(){var L=Ext.define(null,{constructor:G,config:K({})});var M=new L({foo:{}});expect(M._foo).not.toBeDefined()})});it("should not have configs with a custom setter on the instance",function(){var L=Ext.define(null,{constructor:G,config:K(1),setFoo:function(){this.callParent(arguments);return this}});var M=new L();expect(M._foo).not.toBeDefined()});it("should not have configs with a custom applier on the instance",function(){var L=Ext.define(null,{constructor:G,config:K(1),applyFoo:Ext.identityFn});var M=new L();expect(M._foo).not.toBeDefined()});it("should not have configs with a custom updater on the instance",function(){var L=Ext.define(null,{constructor:G,config:K(1),updateFoo:Ext.emptyFn});var M=new L();expect(M._foo).not.toBeDefined()});it("should not call the getter if set is called",function(){var N=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),getFoo:N});var M=new L();M.setFoo(2);expect(N).not.toHaveBeenCalled()})});describe("first call to get",function(){it("should call the applier on the first get call",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});H=new L({});H.getFoo();expect(M).toHaveBeenCalled()});it("should not call the applier on subsequent get calls",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});H=new L({});H.getFoo();H.getFoo();H.getFoo();expect(M.callCount).toBe(1)});it("should call the updater on the first get call",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),updateFoo:M});H=new L({});H.getFoo();expect(M).toHaveBeenCalled()});it("should not call the updater on subsequent get calls",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:G,config:K(1),updateFoo:M});H=new L({});H.getFoo();H.getFoo();H.getFoo();expect(M.callCount).toBe(1)});it("should merge any values for objects",function(){var L=Ext.define(null,{constructor:G,config:{foo:{lazy:true,$value:{z:1}}}});H=new L({foo:{y:2}});expect(H.getFoo()).toEqual({y:2,z:1})})});describe("subclassing",function(){it("should inherit laziness from the parent",function(){var M=jasmine.createSpy();var N=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});var L=Ext.define(null,{extend:N});H=new L();expect(M).not.toHaveBeenCalled();H.getFoo();expect(M).toHaveBeenCalled()});it("should inherit laziness from the parent and allow the value to change",function(){var M=jasmine.createSpy().andCallFake(function(O){return O});var N=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});var L=Ext.define(null,{extend:N,config:{foo:9876}});H=new L();expect(M).not.toHaveBeenCalled();expect(H.getFoo()).toBe(9876)});it("should be able to go from lazy -> !lazy",function(){var M=jasmine.createSpy();var N=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});var L=Ext.define(null,{extend:N,config:{foo:{lazy:false,$value:1}}});H=new L();expect(M).toHaveBeenCalled()});it("should be able to go from !lazy -> lazy",function(){var M=jasmine.createSpy();var N=Ext.define(null,{constructor:G,config:{foo:1},applyFoo:M});var L=Ext.define(null,{extend:N,config:K(1)});H=new L();expect(M).not.toHaveBeenCalled();H.getFoo();expect(M).toHaveBeenCalled()});it("should retain laziness on the superclass",function(){var M=jasmine.createSpy();var N=Ext.define(null,{constructor:G,config:K(1),applyFoo:M});var L=Ext.define(null,{extend:N,config:{foo:{lazy:false,$value:2}}});H=new N();expect(M).not.toHaveBeenCalled();H.getFoo();expect(M).toHaveBeenCalled()})})});describe("merge",function(){var L,M,K;beforeEach(function(){L=jasmine.createSpy()});afterEach(function(){M=K=null});describe("during class definition",function(){function O(R,P,Q){M=Ext.define(null,{constructor:G,config:{foo:{merge:L,$value:R}}});if(!Q){K=Ext.define(null,{extend:M,config:{foo:P}})}}function N(Q,P){Ext.undefine("spec.B");K=Ext.define("spec.B",{config:{foo:P}});M=Ext.define(null,{constructor:G,mixins:[K],config:{foo:{merge:L,$value:Q}}})}afterEach(function(){Ext.undefine("spec.B")});it("should not call the merge fn when defining the config",function(){O({},undefined,true);expect(L).not.toHaveBeenCalled()});describe("merge values",function(){var P=[undefined,null,true,"aString",1,new Date(),{},[]];describe("for subclasses",function(){it("should call the merge function for all value combinations",function(){Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();O(Q,R);expect(L).toHaveBeenCalled()})})})});describe("for mixins",function(){it("should call the merge function for all value combinations",function(){Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();N(Q,R,false,true);expect(L).toHaveBeenCalled()})})})})});describe("merging",function(){it("should pass the sub value, then super value and whether it is from a mixin",function(){var Q={},R={};O(Q,R);var P=L.mostRecentCall;var S=P.args;expect(P.object).toBe(K.$config.configs.foo);expect(S[0]).toBe(R);expect(S[1]).toBe(Q);expect(S[2]).toBe(K);expect(S[3]).toBeFalsy()});describe("with a mixin",function(){it("should pass the mixinClass",function(){N({},{});var P=L.mostRecentCall.args;expect(P[2]).toBe(M);expect(P[3]).toBe(K)})});it("should pass the scope as the Config instance",function(){O({},{});expect(L.mostRecentCall.object).toBe(K.$config.configs.foo)});it("should set the returned value",function(){L=jasmine.createSpy().andReturn({merged:"ok!"});O({},{});H=new K();expect(H.getFoo()).toEqual({merged:"ok!"})})})});describe("instance values",function(){var O;function N(P,Q){O=Ext.define(null,{constructor:G,config:{foo:{merge:L,$value:P}}});H=new O({foo:Q})}afterEach(function(){O=null});describe("merge values",function(){it("should call the merge function for all value combinations",function(){var P=[undefined,null,true,"aString",1,new Date(),{},[]];Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();N(Q,R);expect(L).toHaveBeenCalled()})})})});describe("merging",function(){it("should pass the instance value, then class value",function(){var P;N({foo:1},{bar:1});P=L.mostRecentCall.args;expect(P[0]).toEqual({bar:1});expect(P[1]).toEqual({foo:1})});it("should pass the instance",function(){N({},{});expect(L.mostRecentCall.args[2]).toBe(H)});it("should set the returned value",function(){L=jasmine.createSpy().andReturn({merged:"ok!"});N({},{});expect(H.getFoo()).toEqual({merged:"ok!"})})})});describe("subclassing",function(){it("should inherit the merge from the parent",function(){M=Ext.define(null,{constructor:G,config:{foo:{merge:L,$value:null}}});K=Ext.define(null,{extend:M,config:{foo:{}}});L.reset();H=new K({foo:{}});expect(L).toHaveBeenCalled()});it("should be able to set a merge on a subclass",function(){M=Ext.define(null,{constructor:G,config:{foo:1}});K=Ext.define(null,{extend:M,config:{foo:{merge:L,$value:{}}}});L.reset();H=new K({foo:{}});expect(L).toHaveBeenCalled()});it("should be able to override the merge on a superclass",function(){var N=jasmine.createSpy();L=jasmine.createSpy().andReturn({});M=Ext.define(null,{constructor:G,config:{foo:{merge:N,$value:{}}}});K=Ext.define(null,{extend:M,config:{foo:{merge:L,$value:{}}}});N.reset();L.reset();H=new K({foo:{}});expect(N).not.toHaveBeenCalled();expect(L).toHaveBeenCalled()});it("should retain the merge on the superclass",function(){var N=jasmine.createSpy().andReturn({});M=Ext.define(null,{constructor:G,config:{foo:{merge:N,$value:{}}}});K=Ext.define(null,{extend:M,config:{foo:{merge:L,$value:{}}}});N.reset();L.reset();H=new M({foo:{}});expect(N).toHaveBeenCalled();expect(L).not.toHaveBeenCalled()})})})})});describe("statics",function(){beforeEach(function(){F=function(){}});it("should copy static properties to the class",function(){E=Ext.define(null,{statics:{someName:"someValue",someMethod:F}});expect(E.someName).toBe("someValue");expect(E.someMethod).toBe(F)});it("should not copy statics to subclasses",function(){E=Ext.define(null,{statics:{someName:"someValue",someMethod:F}});I=Ext.define(null,{extend:I});expect(I.someName).not.toBeDefined();expect(I.someMethod).not.toBeDefined()})});describe("inheritableStatics",function(){beforeEach(function(){F=function(){}});it("should store names of inheritable static properties",function(){E=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:F}});expect((new E()).inheritableStatics).not.toBeDefined();expect(E.someName).toBe("someValue");expect(E.prototype.$inheritableStatics).toEqual(["someName","someMethod"]);expect(E.someMethod).toBe(F)});it("should inherit inheritable statics",function(){E=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:F}});I=Ext.define(null,{extend:E});expect(I.someName).toBe("someValue");expect(I.someMethod).toBe(F)});it("should NOT inherit inheritable statics if the class already has it",function(){E=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:F}});I=Ext.define(null,{extend:E,statics:{someName:"someOtherValue",someMethod:function(){}}});expect(I.someName).toBe("someOtherValue");expect(I.someMethod).not.toBe(F)})});describe("addStatics",function(){it("single with name - value arguments",function(){var K=false;C.addStatics({staticMethod:function(){K=true}});expect(C.staticMethod).toBeDefined();C.staticMethod();expect(K).toBeTruthy()});it("multiple with object map argument",function(){C.addStatics({staticProperty:"something",staticMethod:function(){}});expect(C.staticProperty).toBe("something");expect(C.staticMethod).toBeDefined()})});describe("override",function(){it("should override",function(){C.override({myOwnMethod:function(){this.isOverridden=true;this.callOverridden(arguments)}});var K=new C;K.myOwnMethod();expect(K.isOverridden).toBe(true);expect(K.myOwnMethodCalled).toBe(true)});it("should override a default config",function(){E=Ext.define(null,{constructor:G,config:{foo:1}});E.override({config:{foo:2}});expect((new E()).getFoo()).toBe(2)});it("should be able to add a new config",function(){E=Ext.define(null,{constructor:G,config:{foo:1}});E.override({config:{bar:2}});expect((new E()).getBar()).toBe(2)})});describe("private methods",function(){var K;beforeEach(function(){K=Ext.define(null,{bar:function(){},privates:{foo:function(){}}})});describe("extend",function(){it("should allow derived class to override a private method w/a private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{foo:function(){}}})}).not.toThrow()});it("should allow derived class to override a public method w/a private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{bar:function(){}}})}).not.toThrow()});it("should throw when derived class overrides a private method",function(){expect(function(){Ext.define(null,{extend:K,foo:function(){}})}).toThrow()});it("should throw when derived class overrides a private method w/a foreign private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{privacy:"user",foo:function(){}}})}).toThrow()})});describe("override",function(){it("should throw when overriding a private method",function(){expect(function(){K.override({foo:function(){}})}).toThrow()});it("should allow overriding a public method w/a private method",function(){expect(function(){K.override({privates:{bar:function(){}}})}).not.toThrow()});it("should allow overriding a private method w/a private method",function(){expect(function(){K.override({privates:{foo:function(){}}})}).not.toThrow()});it("should throw when derived class overrides a private method w/a foreign private method",function(){expect(function(){K.override({privates:{privacy:"user",foo:function(){}}})}).toThrow()})})});describe("define override",function(){var K,L;beforeEach(function(){L=[];function M(){L.push(this.$className)}Ext.define("Foo.UnusedOverride",{override:"Foo.Nothing",foo:function(N){return this.callParent([N*2])}},M);Ext.define("Foo.SingletonOverride",{override:"Foo.Singleton",foo:function(N){return this.callParent([N*2])}},M);Ext.define("Foo.Singleton",{singleton:true,foo:function(N){return N}});Ext.define("Foo.SomeBase",{patchedMethod:function(N){return N+"A"},statics:{patchedStaticMethod:function(N){return N+"a"},staticMethod:function(N){return"A"+N}}});Ext.define("Foo.SomeClass",{extend:"Foo.SomeBase",prop:1,constructor:function(){this.prop=2},method1:function(N){return"b"+N},patchedMethod:function(){return this.callParent()+"B"},statics:{patchedStaticMethod:function(N){return this.callParent(arguments)+"b"},staticMethod:function(N){return"B"+this.callParent(arguments)}}});Ext.define("Foo.SomeClassOverride",{override:"Foo.SomeClass",constructor:function(){this.callParent(arguments);this.prop*=21},method1:function(N){return"a"+this.callParent([N*2])+"c"},method2:function(){return"two"},patchedMethod:function(N){return this.callSuper(arguments)+"C"},statics:{newStatic:function(){return"boo"},patchedStaticMethod:function(N){return this.callSuper(arguments)+"c"},staticMethod:function(N){return"Z"+this.callParent([N*2])+"!"}}},M);K=Ext.create("Foo.SomeClass")});afterEach(function(){Ext.each(["Foo.SingletonOverride","Foo.Singleton","Foo.SomeClassOverride","Foo.SomeBase","Foo.SomeClass"],function(M){Ext.undefine(M)});Ext.undefine("Foo");K=null});it("should call the createdFn",function(){expect(L.length).toBe(2);expect(L[0]).toBe("Foo.Singleton");expect(L[1]).toBe("Foo.SomeClass")});it("can override constructor",function(){expect(K.prop).toBe(42)});it("can add new methods",function(){expect(K.method2()).toBe("two")});it("can add new static methods",function(){expect(Foo.SomeClass.newStatic()).toBe("boo")});it("callParent should work for instance methods",function(){expect(K.method1(21)).toBe("ab42c")});it("callParent should work for static methods",function(){expect(Foo.SomeClass.staticMethod(21)).toBe("ZBA42!")});it("callSuper should work for instance methods",function(){expect(K.patchedMethod("x")).toBe("xAC")});it("callSuper should work for static methods",function(){expect(Foo.SomeClass.patchedStaticMethod("X")).toBe("Xac")});it("works with singletons",function(){expect(Foo.Singleton.foo(21)).toBe(42)})});describe("mixin",function(){it("should have all properties of mixins",function(){var K=new C;expect(K.mixinProperty1).toBe("mixinProperty1");expect(K.mixinProperty2).toBe("mixinProperty2");expect(K.mixinMethod1).toBeDefined();expect(K.mixinMethod2).toBeDefined();expect(K.getMixinConfig()).toBe("mixinConfig")});it("should not overwrite a config if it exists on the class",function(){var L=Ext.define("spec.Mixin",{config:{foo:1}});var K=Ext.define(null,{constructor:G,mixins:[L],config:{foo:2}});H=new K();expect(H.getFoo()).toBe(2);Ext.undefine("spec.Mixin")})});describe("hooks",function(){var K,L;beforeEach(function(){K="";L=[];Ext.define("Foo.M1",{extend:"Ext.Mixin",mixinConfig:{extended:function(N,O,M){L.push(O.$className+" extends "+N.$className)}},foo:function(M){K+="M1.foo"+M},doBar:function(M){K+="M1.bar"+M}});Ext.define("Foo.M2",{extend:"Foo.M1",mixinConfig:{on:{foo:function(M){this.callParent(arguments);K+="M2.foo"+M},bar:"doBar"}},doBar:function(M){this.callParent(arguments);K+="M2.bar"+M}});Ext.define("Foo.A",{foo:function(M){K+="A.foo"+M},bar:function(M){K+="A.bar"+M}});Ext.define("Foo.B",{extend:"Foo.A",foo:function(M){this.callParent(arguments);K+="B.foo"+M},bar:function(M){this.callParent(arguments);K+="B.bar"+M}});Ext.define("Foo.C",{extend:"Foo.A",mixins:{m2:"Foo.M2"},foo:function(M){this.callParent(arguments);K+="C.foo"+M;return"C.foo"},bar:function(M){this.callParent(arguments);K+="C.bar"+M}});Ext.define("Foo.D",{extend:"Foo.B",mixins:{m2:"Foo.M2"},foo:function(M){this.callParent(arguments);K+="D.foo"+M;return"D.foo"},bar:function(M){this.callParent(arguments);K+="D.bar"+M;return 42}});Ext.define("Foo.E",{extend:"Foo.C",foo:function(M){this.callParent(arguments);K+="B.foo"+M},bar:function(M){this.callParent(arguments);K+="B.bar"+M}})});afterEach(function(){Ext.undefine("Foo.M1");Ext.undefine("Foo.M2");Ext.undefine("Foo.A");Ext.undefine("Foo.B");Ext.undefine("Foo.C");Ext.undefine("Foo.D");Ext.undefine("Foo.E");Ext.undefine("Foo")});it("should call A then M2 then C",function(){var N=new Foo.C(),M=N.foo(" ");expect(K).toBe("A.foo M2.foo C.foo ");expect(M).toBe("C.foo")});it("function hook should call A then B then M2 then C",function(){var N=new Foo.D(),M=N.foo(" ");expect(K).toBe("A.foo B.foo M2.foo D.foo ");expect(M).toBe("D.foo")});it("named hook should call A then B then M2 then C",function(){var N=new Foo.D(),M=N.bar(" - ");expect(K).toBe("A.bar - B.bar - M1.bar - M2.bar - D.bar - ");expect(M).toBe(42)});it("should process extended option",function(){var M=L.join("/");expect(M).toBe("Foo.E extends Foo.C")})});describe("overriden methods",function(){it("should call self constructor",function(){var K=new C;expect(K.subConstructorCalled).toBeTruthy()});it("should call parent constructor",function(){var K=new C;expect(K.parentConstructorCalled).toBeTruthy()});it("should call mixins constructors",function(){var K=new C;expect(K.mixinConstructor1Called).toBeTruthy();expect(K.mixinConstructor2Called).toBeTruthy()})});describe("callbacks",function(){describe("extend",function(){afterEach(function(){Ext.undefine("spec.Extend")});it("should set the scope to the created class",function(){var K=function(){},L;Ext.define("spec.Extend",{extend:"Ext.Base",foo:K},function(){L=this.prototype.foo});expect(L).toBe(K)});it("should pass the created class",function(){var K=function(){},L;Ext.define("spec.Extend",{extend:"Ext.Base",foo:K},function(M){L=M.prototype.foo});expect(L).toBe(K)})});describe("override",function(){var K;beforeEach(function(){K=Ext.define("spec.Base",{})});afterEach(function(){Ext.undefine("spec.Base")});it("should set the scope to the overridden class",function(){var L;Ext.define("spec.Override",{override:"spec.Base"},function(){L=this});expect(L).toBe(K)});it("should pass the overridden class",function(){var L;Ext.define("spec.Override",{override:"spec.Base"},function(M){L=M});expect(L).toBe(K)})})})});