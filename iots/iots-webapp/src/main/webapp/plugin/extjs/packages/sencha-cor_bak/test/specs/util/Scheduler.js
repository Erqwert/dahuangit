describe("Ext.util.Scheduler",function(){var A,D,F;var B,G;var C=0;function E(){E=Ext.emptyFn;D=Ext.define(null,{extend:Ext.util.Schedulable,constructor:function(H){this.name=H;this.scheduler=A;this.callParent()},react:function(){F.push(this.name)},privates:{sort:function(){this.scheduler.sortItems(this.depends)}}})}beforeEach(function(){E();A=new Ext.util.Scheduler({listeners:{busy:function(){++B},idle:function(){++G}}});B=G=0;var H=A.sort;A.sort=function(){++C;return H.apply(this,arguments)};F=[];C=0});afterEach(function(){if(A){A.destroy();A=null}expect(Ext.util.Scheduler.instances.length).toBe(0)});describe("ordering",function(){it("should order items only on first notification",function(){expect(C).toBe(0);var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);H.schedule();I.schedule();expect(C).toBe(0);A.notify();expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2");H.schedule();A.notify();expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2/item1")});it("should react to only what was scheduled",function(){var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);H.schedule();A.notify();expect(F.join("/")).toBe("item1");I.schedule();A.notify();expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2")});it("should reorder items if new items are added",function(){expect(C).toBe(0);var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);H.schedule();I.schedule();expect(C).toBe(0);A.notify();expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2");var J=new D("item3");H.depends=[J];F.length=0;H.schedule();I.schedule();J.schedule();expect(C).toBe(1);A.notify();expect(C).toBe(2);expect(F.join("/")).toBe("item3/item1/item2")});it("should detect dependency cycles",function(){var H=new D("item1");var I=new D("item2");I.depends=[H];H.depends=[I];A.add(I);I.schedule();expect(function(){A.notify()}).toThrow()})});describe("multiple pass notifications",function(){it("should trigger dependent items in single pass",function(){var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);H.schedule();Ext.override(H,{react:function(){I.schedule();return this.callParent()}});expect(A.passes).toBe(0);expect(C).toBe(0);A.notify();expect(A.passes).toBe(1);expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2");A.notify();expect(A.passes).toBe(1);expect(C).toBe(1);expect(F.join("/")).toBe("item1/item2")});it("should trigger anti-dependent items in two passes",function(){var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);I.schedule();Ext.override(I,{react:function(){H.schedule();return this.callParent()}});expect(A.passes).toBe(0);expect(C).toBe(0);A.notify();expect(A.passes).toBe(2);expect(C).toBe(1);expect(F.join("/")).toBe("item2/item1");A.notify();expect(A.passes).toBe(2);expect(C).toBe(1);expect(F.join("/")).toBe("item2/item1")});it("should trigger self in two passes",function(){var H=new D("item1");var I=new D("item2");I.depends=[H];A.add(I);I.schedule();Ext.override(I,{react:function(){delete this.react;I.schedule();return this.callParent()}});expect(A.passes).toBe(0);expect(C).toBe(0);A.notify();expect(A.passes).toBe(2);expect(C).toBe(1);expect(F.join("/")).toBe("item2/item2");A.notify();expect(A.passes).toBe(2);expect(C).toBe(1);expect(F.join("/")).toBe("item2/item2")});it("should limit number of cycles",function(){var H=new D("A");var I=new D("B");var K=100;I.depends=[H];A.add(I);A.setCycleLimit(4);I.schedule();Ext.override(I,{react:function(){if(K--<0){return}H.schedule();return this.callParent()}});Ext.override(H,{react:function(){if(K--<0){return}I.schedule();return this.callParent()}});expect(A.passes).toBe(0);expect(C).toBe(0);var J;A.onCycleLimitExceeded=function(){J=true};A.notify();expect(J).toBe(true);expect(A.passes).toBe(4);expect(C).toBe(1);expect(F.join("")).toBe("BABABAB");J=false;A.notify();expect(J).toBe(true);expect(A.passes).toBe(8);expect(C).toBe(1);expect(F.join("")).toBe("BABABABABABABAB")})});describe("busy / idle",function(){it("should fire nothing initially",function(){expect(B).toBe(0);expect(G).toBe(0);expect(A.isBusy()).toBe(false);expect(A.isIdle()).toBe(true);A.notify();expect(B).toBe(0);expect(G).toBe(0);expect(A.isBusy()).toBe(false);expect(A.isIdle()).toBe(true)});it("should fire busy event",function(){expect(B).toBe(0);expect(G).toBe(0);A.adjustBusy(1);expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false)});it("should not fire the idle event when busy",function(){expect(B).toBe(0);expect(G).toBe(0);A.adjustBusy(1);expect(B).toBe(1);expect(G).toBe(0);A.notify();expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false);A.notify();expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false)});it("should fire idle event",function(){expect(B).toBe(0);expect(G).toBe(0);A.adjustBusy(1);expect(B).toBe(1);expect(G).toBe(0);A.adjustBusy(-1);expect(B).toBe(1);expect(G).toBe(0);for(var H=0;H<2;++H){A.notify();expect(B).toBe(1);expect(G).toBe(1);expect(A.isBusy()).toBe(false);expect(A.isIdle()).toBe(true)}});it("should wait to fire the idle event",function(){expect(B).toBe(0);expect(G).toBe(0);var H=new D("A");Ext.override(H,{react:function(){A.adjustBusy(1);return this.callParent()}});H.schedule();A.notify();expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false);for(var I=0;I<2;++I){A.adjustBusy(-1);H.schedule();A.notify();expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false);A.notify();expect(B).toBe(1);expect(G).toBe(0);expect(A.isBusy()).toBe(true);expect(A.isIdle()).toBe(false)}A.adjustBusy(-1);A.notify();expect(B).toBe(1);expect(G).toBe(1);expect(A.isBusy()).toBe(false);expect(A.isIdle()).toBe(true)})})});