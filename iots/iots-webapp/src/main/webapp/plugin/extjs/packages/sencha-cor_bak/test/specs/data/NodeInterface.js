xdescribe("Ext.data.NodeInterface",function(){function A(C,D,F){var B={fn:F||Ext.emptyFn},E=spyOn(B,"fn");C.addListener(D,B.fn);return E}beforeEach(function(){Ext.define("spec.TreeNode",{extend:"Ext.data.TreeModel",fields:[{name:"text",type:"string"}],proxy:{type:"memory"}})});afterEach(function(){Ext.undefine("spec.TreeNode");Ext.data.Model.schema.clear()});describe("decorating",function(){var B;beforeEach(function(){B=spec.TreeNode.prototype.fields});it("should decorate the Model with a parentId field that has the same type as the idProperty",function(){var D=B.get("parentId"),C=spec.TreeNode.prototype.fields.get(spec.TreeNode.prototype.idProperty).getType().type;expect(D.getPersist()).toBe(true);expect(D.getType().type).toBe(C);expect(D.getDefaultValue()).toBeNull()});it("should decorate the Model with an index field",function(){var C=B.get("index");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("int");expect(C.getDefaultValue()).toBe(-1)});it("should decorate the Model with a depth field",function(){var C=B.get("depth");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("int");expect(C.getDefaultValue()).toBe(0)});it("should decorate the Model with an expanded field",function(){var C=B.get("expanded");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an expandable field",function(){var C=B.get("expandable");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with a checked field",function(){var C=B.get("checked");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("auto");expect(C.getDefaultValue()).toBe(null)});it("should decorate the Model with a leaf field",function(){var C=B.get("leaf");expect(C.getPersist()).toBe(true);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with a cls field",function(){var C=B.get("cls");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an iconCls field",function(){var C=B.get("iconCls");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an icon field",function(){var C=B.get("icon");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a root field",function(){var C=B.get("root");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an isLast field",function(){var C=B.get("isLast");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an isFirst field",function(){var C=B.get("isFirst");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an allowDrop field",function(){var C=B.get("allowDrop");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with an allowDrag field",function(){var C=B.get("allowDrag");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with a loaded field",function(){var C=B.get("loaded");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with a loading field",function(){var C=B.get("loading");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an href field",function(){var C=B.get("href");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an hrefTarget field",function(){var C=B.get("hrefTarget");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a qtip field",function(){var C=B.get("qtip");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a qtitle field",function(){var C=B.get("qtitle");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a children field",function(){var C=B.get("children");expect(C.getPersist()).toBe(false);expect(C.getType().type).toBe("auto");expect(C.getDefaultValue()).toBe(null)});it("should decorate Model class of a given record",function(){var C,D,E;C=Ext.define("spec.MyModel",{extend:"Ext.data.Model",fields:[{name:"text",type:"string"}],proxy:{type:"memory"}});D=C.create({text:"record1"});E=C.create({text:"record2"});expect(C.prototype.isNode).toBeUndefined();expect(D.isNode).toBeUndefined();expect(E.isNode).toBeUndefined();Ext.data.NodeInterface.decorate(D);expect(C.prototype.isNode).toBeTruthy();expect(D.isNode).toBeTruthy();expect(E.isNode).toBeTruthy();Ext.undefine("spec.MyModel")})});describe("methods",function(){var B,G,C,D,F;function E(){C.appendChild(B);C.appendChild(G);C.updateInfo(false,{isFirst:true,isLast:true,depth:0,index:0,parentId:null})}beforeEach(function(){B=new spec.TreeNode({id:"left"});G=new spec.TreeNode({id:"right"});C=new spec.TreeNode({id:"root"});D=new spec.TreeNode({id:"spare"})});describe("isFirst",function(){beforeEach(function(){E.call(this)});it("should have rootNode which is first",function(){expect(C.isFirst()).toBe(true)});it("should have leftChild which is first",function(){expect(B.isFirst()).toBe(true)});it("should have rightChild which is not first",function(){expect(G.isFirst()).toBe(false)})});describe("isLast",function(){beforeEach(function(){E.call(this)});it("should have rootNode which is last",function(){expect(C.isLast()).toBe(true)});it("should have leftChild which is not last",function(){expect(B.isLast()).toBe(false)});it("should have rightChild which is last",function(){expect(G.isLast()).toBe(true)})});describe("hasChildNodes",function(){beforeEach(function(){C.appendChild(B)});it("should have rootNode with children",function(){expect(C.hasChildNodes()).toBe(true)});it("should have leftChild whithout children",function(){expect(B.hasChildNodes()).toBe(false)})});describe("isExpandable",function(){it("should have node expandable if it has children",function(){D.appendChild(B);expect(D.isExpandable()).toBe(true)});it("should have node expandable if has no children",function(){expect(D.isExpandable()).toBe(true)});it("should have node not expandable if it is a leaf node",function(){D.set("leaf",true);expect(D.isExpandable()).toBe(false)})});describe("append",function(){describe("appending children",function(){it("Tree should fire beforeappend when root set",function(){var H=new Ext.data.Tree(),I=new spec.TreeNode({id:"root"});F=A(H,"beforeappend").andCallThrough();H.setRootNode(I);expect(F).toHaveBeenCalledWith(null,I)});it("should fire beforeappend",function(){F=A(C,"beforeappend").andCallThrough();C.appendChild(B);expect(F).toHaveBeenCalledWith(C,B)});it("should cancel append if beforeappend return false",function(){F=A(C,"beforeappend").andReturn(false);expect(C.appendChild(B)).toBe(false);expect(F.callCount).toEqual(1)});it("should set firstChild",function(){C.appendChild(B);expect(C.firstChild).toEqual(B)});it("should set lastChild",function(){C.appendChild(B);expect(C.lastChild).toEqual(B)});it("should add node to childnodes",function(){var H;C.appendChild(B);H=C.childNodes;expect(H.length).toEqual(1);expect(H[0]).toEqual(B)});it("should fire append event",function(){F=A(C,"append").andCallThrough();C.appendChild(B);expect(F).toHaveBeenCalledWith(C,B,0)});it("should return node",function(){var H=C.appendChild(B);expect(H).toEqual(B)});it("should append array of nodes",function(){C.appendChild([B,G]);var H=C.childNodes;expect(H[0]).toEqual(B);expect(H[1]).toEqual(G);expect(H.length).toEqual(2)})});describe("appending with existing siblings",function(){beforeEach(function(){E.call(this)});it("should set next sibling",function(){expect(B.nextSibling).toEqual(G);expect(G.nextSibling).toBeNull()});it("should set previous sibling",function(){expect(G.previousSibling).toEqual(B);expect(B.previousSibling).toBeNull()})});describe("appending children from an existing node",function(){var H,I;beforeEach(function(){H=new spec.TreeNode({id:"oldparent"});H.appendChild(D)});it("should remove from existing node",function(){I=spyOn(H,"removeChild").andCallThrough();C.appendChild(D);expect(I).toHaveBeenCalledWith(D,false,false,true)});it("should fire beforeremove event",function(){I=A(H,"beforeremove").andCallThrough();C.appendChild(D);expect(I).toHaveBeenCalledWith(H,D,true)});it("should fire remove event",function(){I=A(H,"remove").andCallThrough();C.appendChild(D);expect(I).toHaveBeenCalledWith(H,D,true)});it("should fire beforemove event",function(){I=A(D,"beforemove").andCallThrough();C.appendChild(D);expect(I).toHaveBeenCalledWith(D,H,C,0)});it("should fire move event",function(){I=A(D,"move").andCallThrough();C.appendChild(D);expect(I).toHaveBeenCalledWith(D,H,C,0)})})});describe("insert",function(){beforeEach(function(){C.appendChild(G)});describe("inserting children",function(){it("should call appendChild if the node to insert before is null",function(){F=spyOn(C,"appendChild");C.insertBefore(B);expect(F).toHaveBeenCalledWith(B)});it("should do nothing if the node to insert before is equal to the node to insert",function(){expect(C.insertBefore(B,B)).toBe(false)});it("should fire beforeinsert",function(){F=A(C,"beforeinsert").andCallThrough();C.insertBefore(B,G);expect(F).toHaveBeenCalledWith(C,B,G)});it("should cancel insert if beforeinsert return false",function(){F=A(C,"beforeinsert").andReturn(false);expect(C.insertBefore(B,G)).toBe(false);expect(F.callCount).toEqual(1)});it("should set firstChild",function(){C.insertBefore(B,G);expect(C.firstChild).toEqual(B)});it("should set lastChild",function(){C.insertBefore(B,G);expect(C.lastChild).toEqual(G)});it("should fire insert",function(){F=A(C,"insert").andCallThrough();C.insertBefore(B,G);expect(F).toHaveBeenCalledWith(C,B,G)});it("should update indexes for all siblings after the position where the node was inserted",function(){C.insertBefore(D,G);C.insertBefore(B,D);expect(D.get("index")).toEqual(1);expect(G.get("index")).toEqual(2)});it("should handle siblings",function(){expect(B.previousSibling).toBeNull();expect(B.nextSibling).toBeNull();expect(G.previousSibling).toBeNull();expect(G.nextSibling).toBeNull();C.insertBefore(B,G);expect(B.previousSibling).toBeNull();expect(B.nextSibling).toEqual(G);expect(G.previousSibling).toEqual(B);expect(G.nextSibling).toBeNull()});describe("move",function(){beforeEach(function(){C.appendChild(B)});it("should fire beforemove",function(){F=A(B,"beforemove").andCallThrough();C.insertBefore(B,G);expect(F).toHaveBeenCalledWith(B,C,C,0,G)});it("should cancel insert if beforemove return false",function(){F=A(B,"beforemove").andReturn(false);expect(C.insertBefore(B,G)).toBe(false);expect(F.callCount).toEqual(1)});it("should fire move",function(){F=A(B,"move").andCallThrough();C.insertBefore(B,G);expect(F).toHaveBeenCalledWith(B,C,C,0,G)})})})});describe("removing children",function(){it("should return false when removing bad node",function(){expect(C.removeChild(B)).toBe(false)});it("should fire beforeremove event",function(){E.call(this);F=A(C,"beforeremove").andCallThrough();C.removeChild(B);expect(F).toHaveBeenCalledWith(C,B,false)});it("should cancel remove if beforeremove returns false",function(){E.call(this);F=A(C,"beforeremove").andReturn(false);expect(C.removeChild(B)).toBe(false);expect(F.callCount).toEqual(1)});it("should fire remove event",function(){E.call(this);F=A(C,"remove").andCallThrough();C.removeChild(B);expect(F).toHaveBeenCalledWith(C,B,false)});it("should remove child from childNodes",function(){var I,H;E.call(this);I=C.childNodes;H=I.length;C.removeChild(B);expect(I.length).toEqual(H-1);expect(I[0]).toEqual(G)});it("should manage siblings",function(){E.call(this);C.appendChild(D);C.removeChild(G);expect(B.nextSibling,D);expect(D.previousSibling,B)});it("should destroy node if asked",function(){E.call(this);F=spyOn(B,"destroy").andCallThrough();C.removeChild(B,true);expect(F).toHaveBeenCalled()});it("should clear node if asked",function(){E.call(this);F=spyOn(B,"clear").andCallThrough();C.removeChild(B,false);expect(F).toHaveBeenCalled()});it("should update indexes for all siblings after the node's old position",function(){E.call(this);C.appendChild(D);C.removeChild(B);expect(G.get("index")).toEqual(0);expect(D.get("index")).toEqual(1)})});describe("clearing references",function(){beforeEach(function(){E.call(this);C.appendChild(D)});it("should nullify parentNode",function(){expect(G.parentNode).not.toBeNull();G.clear();expect(G.parentNode).toBeNull()});it("should nullifies nextSibling",function(){expect(G.nextSibling).not.toBeNull();G.clear();expect(G.nextSibling).toBeNull()});it("should nullifies previousSibling",function(){expect(G.previousSibling).not.toBeNull();G.clear();expect(G.previousSibling).toBeNull()});it("should remove lastChild and firstChild references",function(){G.clear(true);expect(G.firstChild).toBeNull();expect(G.lastChild).toBeNull()})});describe("item",function(){it("should return the child node at the specified index",function(){C.appendChild(B);C.appendChild(G);C.appendChild(D);expect(C.getChildAt(0)).toEqual(B);expect(C.getChildAt(1)).toEqual(G);expect(C.getChildAt(2)).toEqual(D)})});describe("silent destroy",function(){it("should purge node listeners",function(){F=spyOn(B,"clearListeners").andCallThrough();B.destroy(true);expect(F).toHaveBeenCalled()});it("should clear node",function(){F=spyOn(B,"clear").andCallThrough();B.destroy(true);expect(F).toHaveBeenCalled()});it("should destroy children",function(){var H;E.call(this);F=spyOn(B,"destroy").andCallThrough();H=spyOn(G,"destroy").andCallThrough();C.destroy(true);expect(F).toHaveBeenCalledWith(true);expect(H).toHaveBeenCalledWith(true)});it("should nullifies childNodes",function(){E.call(this);expect(C.childNodes).not.toBeNull();C.destroy(true);expect(C.childNodes).toBeNull()})});describe("non-silent destroy",function(){it("should remove node",function(){E.call(this);F=spyOn(B,"remove").andCallThrough();B.destroy(false);expect(F).toHaveBeenCalled()})});describe("remove",function(){it("should remove from parent",function(){F=spyOn(C,"removeChild").andCallThrough();C.appendChild(B);B.remove();expect(F).toHaveBeenCalledWith(B,undefined,undefined)});it("should return node",function(){expect(B.remove()).toEqual(B)})});describe("removeAll",function(){it("should remove all children",function(){C.removeAll();expect(C.childNodes.length).toEqual(0)})});describe("replacing children",function(){beforeEach(function(){E.call(this)});it("should keep the same childNodes length",function(){var H=C.childNodes.length;C.replaceChild(D,B);expect(C.childNodes.length).toEqual(H)});it("should replace node",function(){C.replaceChild(D,B);expect(C.childNodes[0],D)})});describe("getting depth",function(){beforeEach(function(){E.call(this);B.appendChild(D)});it("should have a depth of 0 for rootNode",function(){expect(C.getDepth()).toEqual(0)});it("should have a depth of 1 for leftChild and rightChild",function(){expect(G.getDepth()).toEqual(1);expect(B.getDepth()).toEqual(1)});it("should have a depth of 2 for spareNode",function(){expect(D.getDepth()).toEqual(2)})});describe("setting ID",function(){var H;beforeEach(function(){H=new Ext.data.Tree();H.setRootNode(C)});it("should change id field",function(){C.setId("yhwh");expect(C.getId()).toEqual("yhwh");expect(C.get("id")).toEqual("yhwh")})});describe("getting path",function(){beforeEach(function(){E.call(this);B.appendChild(D)});it("should set root path",function(){expect(C.getPath()).toEqual("/root")});it("should set middle path",function(){expect(B.getPath()).toEqual("/root/left");expect(G.getPath()).toEqual("/root/right")});it("should set leaf path",function(){expect(D.getPath()).toEqual("/root/left/spare")})});describe("indexOf",function(){it("should always return -1 when the node is empty",function(){expect(C.indexOf(D)).toBe(-1)});it("should return -1 when the passed node is not a child",function(){C.appendChild(B);expect(C.indexOf(D)).toBe(-1)});it("should return the correct index when the node exists",function(){C.appendChild([B,D,G]);expect(C.indexOf(D)).toBe(1)})});describe("indexOfId",function(){it("should always return -1 when the node is empty",function(){expect(C.indexOfId("spare")).toBe(-1)});it("should return -1 when the passed node is not a child",function(){C.appendChild(B);expect(C.indexOfId("spare")).toBe(-1)});it("should return the correct index when the node exists",function(){C.appendChild([B,D,G]);expect(C.indexOfId("spare")).toBe(1)})});describe("bubbling",function(){var H;beforeEach(function(){E.call(this);B.appendChild(D);H=jasmine.createSpy()});it("should call bubbleFn 3 times",function(){D.bubble(H);expect(H.callCount).toEqual(3)});it("should call bubbleFn with node spare, left, root",function(){D.bubble(H);expect(H.calls[0].args).toEqual([D]);expect(H.calls[1].args).toEqual([B]);expect(H.calls[2].args).toEqual([C])});it("should call bubbleFn with a defined scope",function(){D.bubble(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope);expect(H.calls[2].object).toBe(fakeScope)});it("should call bubbleFn with customs arguments",function(){var I=["some","args"];D.bubble(H,D,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I);expect(H.calls[2].args).toEqual(I)});it("should stop when bubbleFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});D.bubble(H);expect(H.callCount).toEqual(2)})});describe("cascading",function(){var H;beforeEach(function(){E.call(this);B.appendChild(D);H=jasmine.createSpy()});it("should call cascadeFn 4 times",function(){C.cascadeBy(H);expect(H.callCount).toEqual(4)});it("should call cascadeFn with node root, leftChild, spareNode, rightChild",function(){C.cascadeBy(H);expect(H.calls[0].args).toEqual([C]);expect(H.calls[1].args).toEqual([B]);expect(H.calls[2].args).toEqual([D]);expect(H.calls[3].args).toEqual([G])});it("should call cascadeFn with a defined scope",function(){C.cascadeBy(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope);expect(H.calls[2].object).toBe(fakeScope);expect(H.calls[3].object).toBe(fakeScope)});it("should call cascadeFn with customs arguments",function(){var I=["some","args"];C.cascadeBy(H,C,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I);expect(H.calls[2].args).toEqual(I);expect(H.calls[3].args).toEqual(I)});it("should stop at end of branch when cascadeFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});C.cascadeBy(H);expect(H.callCount).toEqual(3)})});describe("each child",function(){var H;beforeEach(function(){E.call(this);H=jasmine.createSpy()});it("should be called 2 times",function(){C.eachChild(H);expect(H.callCount).toEqual(2)});it("should call eachFn with node root, leftChild, rightChild",function(){C.eachChild(H);expect(H.calls[0].args).toEqual([B]);expect(H.calls[1].args).toEqual([G])});it("should call eachFn with a defined scope",function(){C.eachChild(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope)});it("should call eachFn with customs arguments",function(){var I=["some","args"];C.eachChild(H,C,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I)});it("should stop when eachFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});C.eachChild(H);expect(H.callCount).toEqual(1)})});describe("ancestors",function(){beforeEach(function(){E.call(this);B.appendChild(D)});it("should have parent as ancestor",function(){expect(D.isAncestor(B)).toBe(true)});it("should have root as ancestor",function(){expect(D.isAncestor(C)).toBe(true)});it("should not have uncle as ancestor",function(){expect(D.isAncestor(G)).toBe(false)})});describe("contains",function(){beforeEach(function(){E.call(this);B.appendChild(D)});it("should contain child",function(){expect(C.contains(B)).toBe(true)});it("should contain grand child",function(){expect(C.contains(D)).toBe(true)});it("should not contain parent",function(){expect(D.contains(B)).toBe(false)})});describe("finding children",function(){beforeEach(function(){E.call(this);B.appendChild(D)});describe("findChild",function(){it("should find shallow children",function(){expect(C.findChild("id","left")).toEqual(B)});it("should not find deep children if deep is not specified",function(){expect(C.findChild("id","spare")).toBeNull()});it("should not find deep children if deep is false",function(){expect(C.findChild("id","spare",false)).toBeNull()});it("should find deep children if deep is true",function(){expect(C.findChild("id","spare",true)).toEqual(D)})});describe("findChildBy",function(){var H;it("should find shallow children",function(){H=C.findChildBy(function(I){return I.getId()=="right"});expect(H).toEqual(G)});it("should not find deep children if deep is not specified",function(){H=C.findChildBy(function(I){return I.getId()=="spare"});expect(H).toBeNull()});it("should not find deep children if deep is false",function(){H=C.findChildBy(function(I){return I.getId()=="spare"},this,false);expect(H).toBeNull()});it("should find deep children if deep is true",function(){H=C.findChildBy(function(I){return I.getId()=="spare"},this,true);expect(H).toEqual(D)});it("should call function with good scope",function(){var I=jasmine.createSpy().andReturn(false);H=C.findChildBy(I,fakeScope,true);expect(I.calls[0].object).toBe(fakeScope);expect(I.calls[1].object).toBe(fakeScope);expect(I.calls[2].object).toBe(fakeScope)})})});describe("sort",function(){var H,I,J,K,L;beforeEach(function(){Ext.define("spec.EmployeeTreeNode",{extend:"Ext.data.Model",fields:[{name:"lastname",type:"string"},{name:"firstname",type:"string"}]});Ext.data.NodeInterface.decorate(spec.EmployeeTreeNode);H=new spec.EmployeeTreeNode({lastname:"Avins",firstname:"Jamie"});I=new spec.EmployeeTreeNode({lastname:"Dougan",firstname:"Robert"});J=new spec.EmployeeTreeNode({lastname:"Ferrero",firstname:"Nicolas"});K=new spec.EmployeeTreeNode({lastname:"Spencer",firstname:"Edward"});C.appendChild([K,I,J,H]);L=jasmine.createSpy();L.andCallFake(function(N,M){if(N.get("lastname")===M.get("lastname")){return 0}return(N.get("lastname")<M.get("lastname"))?-1:1});C.sort(L)});afterEach(function(){Ext.undefine("spec.EmployeeTreeNode")});it("should sort the child by lastname with the correct function",function(){expect(C.childNodes[0]).toEqual(H);expect(C.childNodes[1]).toEqual(I);expect(C.childNodes[2]).toEqual(J);expect(C.childNodes[3]).toEqual(K)})});describe("copy",function(){it("should not copy childNodes by default",function(){var H=new spec.TreeNode({text:"Text",id:1});var I=H.copy();expect(I.getData()).toEqual({allowDrag:true,allowDrop:true,checked:null,children:null,cls:"",depth:0,expandable:true,expanded:false,href:"",hrefTarget:"",icon:"",iconCls:"",id:1,index:-1,isFirst:false,isLast:false,leaf:false,loaded:false,loading:false,parentId:null,qtip:"",qtitle:"",qshowDelay:0,root:false,text:"Text",visible:true})});it("should accept a new id",function(){var H=new spec.TreeNode({text:"Text",id:1});var I=H.copy(2);expect(I.getData()).toEqual({allowDrag:true,allowDrop:true,checked:null,children:null,cls:"",depth:0,expandable:true,expanded:false,href:"",hrefTarget:"",icon:"",iconCls:"",id:2,index:-1,isFirst:false,isLast:false,leaf:false,loaded:false,loading:false,parentId:null,qtip:"",qtitle:"",qshowDelay:0,root:false,text:"Text",visible:true})});it("should clone children if deep: true is specified",function(){var I=new spec.TreeNode({id:1,text:"Root"});var J=I.appendChild(new spec.TreeNode({id:2,text:"Child1"}));var H=J.appendChild(new spec.TreeNode({id:3,text:"Child2"}));H.appendChild(new spec.TreeNode({id:4,text:"Child3"}));var K=I.copy(undefined,true);expect(K.childNodes[0].getId()).toBe(2);expect(K.childNodes[0].get("text")).toBe("Child1");K=K.childNodes[0];expect(K.childNodes[0].getId()).toBe(3);expect(K.childNodes[0].get("text")).toBe("Child2");K=K.childNodes[0];expect(K.childNodes[0].getId()).toBe(4);expect(K.childNodes[0].get("text")).toBe("Child3")})})});describe("serialize",function(){it("should not include children if there are none",function(){var C=new spec.TreeNode({text:"foo"}),B=C.serialize();expect(B.text).toBe("foo");expect(B.children).toBeUndefined()});it("should include children if they exist",function(){var C=new spec.TreeNode({text:"foo"}),B;C.appendChild(new spec.TreeNode({text:"bar"}));B=C.serialize();expect(B.text).toBe("foo");expect(B.children[0].text).toBe("bar")})});describe("collapse",function(){it("should fire the collapse callback when there are no child nodes",function(){var B=new spec.TreeNode(),C;B.collapseChildren(false,function(){C=true});expect(C).toBe(true);B=null})});describe("modified property tracking",function(){it("should track modifications of fields set as a result of node movement",function(){Ext.define("spec.PersistentIndexTreeNode",{extend:"Ext.data.TreeModel",fields:[{name:"text",type:"string"},{name:"index",type:"int",persist:true,defaultValue:-1}],proxy:{type:"memory"}});var C=new spec.PersistentIndexTreeNode({id:"TestRoot"}),E=new spec.PersistentIndexTreeNode({id:"OtherTestRoot"}),D=new spec.PersistentIndexTreeNode({id:"node"}),B;C.appendChild(D);expect(D.modified).toEqual({index:-1,parentId:null});D.commit();expect(D.modified).toEqual({});E.appendChild(D);expect(D.modified).toEqual({parentId:"TestRoot",index:0});D.commit();E.removeChild(D);expect(D.modified).toEqual({});D=new spec.PersistentIndexTreeNode({id:"node"});B=new spec.PersistentIndexTreeNode({id:"node1"});C.clear();C.appendChild([D,B]);expect([D.get("index"),B.get("index")]).toEqual([0,1]);D.commit();B.commit();C.insertBefore(B,D);expect([B.get("index"),D.get("index")]).toEqual([0,1]);expect(B.modified).toEqual({index:1});expect(D.modified).toEqual({index:0});E.appendChild(B);Ext.undefine("spec.PersistentIndexTreeNode")})})});