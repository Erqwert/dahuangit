describe("Ext.app.ViewModel",function(){var C,K,I,D;function J(Q,R,S){var T=C.bind(Q,R||D,S);T.deep=true;C.notify();return T}function P(Q,R,S){var T=C.bind(Q,R||D,S);C.notify();return T}function B(Q,R){C.set(Q,R);C.notify()}function G(){C.notify()}function F(){for(var Q=0,R=arguments.length;Q<R;++Q){arguments[Q].reset()}}function O(R,Q){if(arguments.length===1){N(D.mostRecentCall,R)}else{N(D.mostRecentCall,R,Q)}}function N(S,R,Q){var T=S.args;expect(T[0]).toBe(R);if(arguments.length>2){expect(T[1]).toBe(Q)}}function H(R,S,Q){Q=Ext.apply({id:S},Q);return new R(Q,I)}function E(Q){if(Q){I=new Ext.data.Session({scheduler:{tickDelay:9999}})}C=new Ext.app.ViewModel({id:"rootVM",session:I});K=C.getScheduler()}function L(Q){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(Q)})}function M(Q){L(Q);G()}beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");MockAjaxManager.addMethods();D=jasmine.createSpy()});afterEach(function(){Ext.destroy(C);Ext.destroy(I);I=K=D=C=null;MockAjaxManager.removeMethods();Ext.data.Model.schema.clear(true)});describe("getting/setting values",function(){beforeEach(function(){E()});describe("set",function(){it("should set a root value if the param is an object",function(){C.set({foo:{bar:1},baz:2});expect(C.getData().foo.bar).toBe(1);expect(C.getData().baz).toBe(2)});it("should set an object at a path",function(){C.set("foo.bar",{baz:1});expect(C.getData().foo.bar.baz).toBe(1)});it("should set a path + primitive",function(){C.set("foo.bar",100);expect(C.getData().foo.bar).toBe(100)});it("should be able to set object instances and not descend into them",function(){var Q=Ext.define(null,{foo:1});var R=new Q();C.set("obj",R);expect(C.getData().obj).toBe(R)})});describe("get",function(){it("should be able to retrieve a value at the root",function(){C.set("foo",1);expect(C.get("foo")).toBe(1)});it("should descend into a path",function(){C.set({foo:{bar:{baz:100}}});expect(C.get("foo.bar.baz")).toBe(100)});it("should return null if the value has not presented",function(){expect(C.get("something")).toBeNull()})})});describe("bind/set for non records/stores",function(){beforeEach(function(){E()});function Q(R){function S(T,U){if(R){T();U()}else{U();T()}}describe(R?"bind before set":"set before bind",function(){describe("setting simple value types",function(){it("should set a number",function(){S(function(){P("{age}",D)},function(){B("age",3)});O(3,undefined)});it("should set a string",function(){S(function(){P("{name}",D)},function(){B("name","Kenneth")});O("Kenneth",undefined)});it("should set a bool",function(){S(function(){P("{active}",D)},function(){B("active",true)});O(true,undefined)});it("should set an array",function(){var T=[18,22,13];S(function(){P("{scores}",D)},function(){B("scores",T)});O(T,undefined)});it("should set a date",function(){var T=new Date(1980,0,1);S(function(){P("{dob}",D)},function(){B("dob",T)});O(T,undefined)});it("should set an object instance",function(){var T=new Ext.util.HashMap();S(function(){P("{myMap}",D)},function(){B("myMap",T)});O(T,undefined)})});describe("using bind options",function(){it("should set a value using bindTo",function(){S(function(){P({bindTo:"{age}"},D)},function(){B("age",3);B("age",5)});if(R){N(D.calls[0],3,undefined);N(D.calls[1],5,3)}else{O(5,undefined)}});it("should set the value once when using single: true",function(){S(function(){P({bindTo:"{age}",single:true},D)},function(){B("age",3);B("age",5)});expect(D.callCount).toBe(1);if(R){O(3,undefined)}else{O(5,undefined)}});it("should bind deep",function(){S(function(){P({bindTo:"{foo}",deep:true},D)},function(){B({foo:{bar:1}});B("foo.bar",2)});if(R){expect(D.callCount).toBe(2)}else{expect(D.mostRecentCall.args[0]).toEqual({bar:2})}})});describe("setting objects",function(){it("should set to the root if there's no name",function(){S(function(){P("{name}",D)},function(){B("",{name:"Bar"})});O("Bar",undefined)});it("should be able to set simple nested properties",function(){S(function(){P("{user.name}",D)},function(){B("user",{name:"Foo"})});O("Foo",undefined)});it("should set deeply nested properties",function(){S(function(){P("{a.b.c.d.e.f.g}",D)},function(){B("a",{b:{c:{d:{e:{f:{g:"val"}}}}}})});O("val",undefined)});it("should be able to set mixes of values/objects",function(){var T=jasmine.createSpy();S(function(){C.bind("{user.name}",D);C.bind("{user.address.city}",T);G()},function(){B("user",{name:"Foo",address:{city:"Paris"}})});O("Foo",undefined);N(T.mostRecentCall,"Paris")})});describe("callback settings",function(){it("should pass the old and new value",function(){S(function(){P("{name}",D)},function(){B("name","Foo");B("name","Bar")});if(R){N(D.calls[0],"Foo",undefined);N(D.calls[1],"Bar","Foo")}else{O("Bar",undefined)}});it("should default the scope to the session",function(){S(function(){P("{name}",D)},function(){B("name","X")});expect(D.mostRecentCall.object).toBe(C)});it("should use the passed scope",function(){var T={};S(function(){P("{name}",D,T)},function(){B("name","X")});expect(D.mostRecentCall.object).toBe(T)})});describe("timing of callbacks",function(){it("should not trigger the callback if the value doesn't change",function(){S(function(){P("{name}",D)},function(){B("name","Foo")});D.reset();B("name","Foo");expect(D).not.toHaveBeenCalled()});it("should not trigger any parent nodes if the leaf value doesn't change",function(){var T=jasmine.createSpy();S(function(){C.bind("{foo}",D);C.bind("{foo.bar}",T)},function(){C.set("foo.bar.baz.x","Foo")});G();F(D,T);B("foo.bar.baz.x","Foo");expect(D).not.toHaveBeenCalled();expect(T).not.toHaveBeenCalled()});it("should be able to bind twice to the same stub",function(){var T=jasmine.createSpy();S(function(){P("{name}",D);P("{name}",T)},function(){B("name","A")});N(D.mostRecentCall,"A",undefined);N(T.mostRecentCall,"A",undefined)});it("should trigger a new binding when there is a set pending",function(){var T=jasmine.createSpy();S(function(){P("{name}",D)},function(){C.set("name","A")});P("{name}",T);expect(T).toHaveBeenCalled()});it("should only fire a single callback inside the timer resolution",function(){S(function(){P("{name}",D)},function(){C.set("name","A");C.set("name","B");C.set("name","C");C.set("name","D");G()});expect(D.callCount).toBe(1);O("D",undefined)});it("should only pass the last value since the last fired change",function(){S(function(){P("{name}",D)},function(){B("name","A")});C.set("name","B");C.set("name","C");C.set("name","D");C.set("name","E");G();O("E","A")});if(R){it("should not trigger the binding initially if a value is not set",function(){P("{name}",D);expect(D).not.toHaveBeenCalled()});it("should suspend the initial binding if the value is set within the tick window",function(){C.bind("{name}",D);B("name","Foo");O("Foo",undefined)})}else{it("should trigger the binding initially if a value exists",function(){C.set("name","Foo");P("{name}",D);expect(D).toHaveBeenCalled();O("Foo",undefined)})}});describe("binding on nested values",function(){it("should trigger a new long chain binding",function(){S(function(){P("{user.address.city}",D)},function(){B("user.address.city","Sydney")});O("Sydney",undefined)});it("should trigger a deep parent binding when a child changes",function(){var T=jasmine.createSpy(),U=jasmine.createSpy();S(function(){P("{user.address.city}",T);J("{user.address}",U)},function(){B("user.address.city","Berlin")});N(T.mostRecentCall,"Berlin",undefined);expect(U.mostRecentCall.args[0]).toEqual({city:"Berlin"})});it("should trigger all deep parent bindings when a child changes",function(){var T=jasmine.createSpy(),U=jasmine.createSpy(),V=jasmine.createSpy();S(function(){P("{user.address.city}",T);J("{user.address}",U);J("{user}",V)},function(){B("user.address.city","Jakarta")});expect(T).toHaveBeenCalled();expect(U).toHaveBeenCalled();expect(V).toHaveBeenCalled()});it("should trigger parent bindings even if a node in the hierarchy is skipped",function(){var T=jasmine.createSpy(),U=jasmine.createSpy();S(function(){P("{user.address.city}",T);J("{user}",U)},function(){B("user.address.city","London")});expect(T).toHaveBeenCalled();expect(U).toHaveBeenCalled()});it("should only trigger the parent binding once if several direct children change",function(){S(function(){J("{user.address}",D)},function(){C.set("user.address.street","1 Foo St");C.set("user.address.city","Moscow");C.set("user.address.zip",12345);C.set("user.address.country","Russia");G()});expect(D.callCount).toBe(1)});it("should only trigger the parent once even if several indirect children change",function(){S(function(){J("{user}",D)},function(){C.set("user.homeAddress.street","Foo");C.set("user.homeAddress.city","Florida");C.set("user.postalAddress.street","Bar");C.set("user.postalAddress.city","Baltimore");G()});expect(D.callCount).toBe(1)});describe("modifying hierarchies",function(){function T(U){return{foo:{bar:{baz:{xxx:U}}}}}it("should trigger changes on the children when hierarchy is overwritten with a primitive",function(){var W=jasmine.createSpy(),V=jasmine.createSpy(),U=jasmine.createSpy();S(function(){C.bind("{foo.bar.baz.xxx}",W);C.bind("{foo.bar.baz}",V);C.bind("{foo.bar}",U);G()},function(){B("foo.bar.baz.xxx",1)});F(W,V,U);B("foo",1);expect(W).toHaveBeenCalled();expect(V).toHaveBeenCalled();expect(U).toHaveBeenCalled()});it("should trigger changes on the children when hierarchy is overwritten with null",function(){S(function(){C.bind("{foo.bar}",D);G()},function(){C.set({foo:{bar:1}});G()});D.reset();B("foo",null);O(null,1)});it("should set the child value correctly when changing a hierarchy in a single tick",function(){S(function(){C.bind("{foo.bar.baz.xxx}",D)},function(){C.set(T(123));C.set(T(456));C.set(T(789))});G();expect(D.callCount).toBe(1);O(789)});it("should set the child value correctly when changing a hierarchy over multiple ticks",function(){S(function(){C.bind("{foo.bar.baz.xxx}",D)},function(){C.set(T(123))});G();O(123);C.set(T(456));G();O(456);C.set(T(789));G();O(789)});it("should set the child value correctly when overwriting a hierarchy in a single tick",function(){S(function(){C.bind("{foo.bar.baz.xxx}",D)},function(){C.set(T(123));C.set(T(456));C.set({foo:null})});G();if(R){expect(D.callCount).toBe(1);O(null)}else{expect(D).not.toHaveBeenCalled()}});it("should set the child value correctly when overwriting a hierarchy over multiple ticks",function(){S(function(){C.bind("{foo.bar.baz.xxx}",D)},function(){C.set(T(123))});G();O(123);C.set(T(456));G();O(456);C.set({foo:null});G();O(null)});it("should be able to expand a primitive into a hierarchy",function(){var W=jasmine.createSpy(),V=jasmine.createSpy(),U=jasmine.createSpy();S(function(){C.bind("{foo.bar.baz.xxx}",W,null,{deep:true});C.bind("{foo.bar.baz}",V,null,{deep:true});C.bind("{foo.bar}",U,null,{deep:true})},function(){C.set("foo",1)});G();F(W,V,U);B("foo.bar.baz.xxx",1);expect(W).toHaveBeenCalled();expect(V).toHaveBeenCalled();expect(U).toHaveBeenCalled()});if(R){it("should set the child value correctly when expanding a hierarchy in a single tick",function(){C.bind("{foo.bar.baz.xxx}",D);G();C.set({foo:null});C.set({foo:{bar:null}});C.set({foo:{bar:{baz:null}}});C.set({foo:{bar:{baz:{xxx:100}}}});G();expect(D.callCount).toBe(1);O(100)});it("should set the child value correctly when expanding a hierarchy over multiple ticks",function(){C.bind("{foo.bar.baz.xxx}",D);G();C.set({foo:null});G();expect(D).not.toHaveBeenCalled();C.set({foo:{bar:null}});G();expect(D).not.toHaveBeenCalled();C.set({foo:{bar:{baz:null}}});G();expect(D).not.toHaveBeenCalled();C.set({foo:{bar:{baz:{xxx:100}}}});G();O(100);C.set({foo:null});G();O(null)})}})})})}Q(false);Q(true);describe("firing order",function(){it("should fire children before parents",function(){var R=[];C.bind("{address}",function(S){R.push("address: "+Ext.encode(S))}).deep=true;C.bind("{address.city}",function(S){R.push("address.city: "+S)});G();expect(R).toEqual([]);C.set("address.city","Melbourne");G();expect(R[0]).toBe("address.city: Melbourne");expect(R[1]).toBe('address: {"city":"Melbourne"}')});it("should fire a single binding at the depth of it's stub",function(){B("foo.bar.baz.x",1);var S=[],R=function(T){S.push(T)};C.bind("{foo.bar.baz.x}",R);C.bind("{foo.bar.y}",R);C.set("foo.bar.y",3);C.set("foo.bar.baz.x",2);G();expect(S[0]).toBe(2);expect(S[1]).toBe(3)});it("should fire complex hierarchies in depth order",function(){var S={key1:{key11:{key111:{key1111:"a",key1112:"b"},key112:"c"},key12:{key121:"d",key122:"e"}},key2:{key21:{key211:"f"},key22:{key221:{key2211:{key22111:"g"}},key222:{key2221:"h"}},key23:{key231:"i"}},key3:{key31:"j",key32:{key321:"k"},key33:{key331:{key3311:"l"},key332:"m"}},key4:{key41:"n"},key5:"o",key6:{key61:{key611:{key6111:{key61111:{key611111:{key6111111:"p"},key611112:"q"}}},key612:{key6121:{key61211:{key61211:"r"}}},key613:{key6131:{key61311:{key613111:{key6131111:"s"}}}}}}};var Y={};var X=[];var T=[];var R=[];function Z(c,d,e){var b={id:X.length+1,path:e,parent:d,value:c};X.push(Y[e]=b);if(e){C.bind("{"+e+"}",function(g){T.push(b);R.push(g);for(var f=d;f;f=f.parent){expect(Ext.Array.contains(T,f)).toBe(false)}})}if(c&&c.constructor===Object){var a=e?e+".":"";Ext.Object.each(c,function(f,g){Z(g,b,a+f)})}return b}var U=Z(S,null,""),W,V;G();for(V=0;V<R.length;++V){W=T[V].path+"=";expect(W+R[V]).toEqual(W+"null")}T.length=R.length=0;B("",S);G();for(V=0;V<R.length;++V){expect(R[V]).toBe(T[V].value)}})})});describe("parsing formulas",function(){var S;function R(U){var T=S.getStub(U);return T.formula}function Q(U){var V=R(U),T=Ext.apply({},V.get.$expressions);delete T.$literal;return Ext.Object.getKeys(T)}beforeEach(function(){E()});afterEach(function(){S.destroy();S=null});describe("simple formulas",function(){it("should recognize property access",function(){S=new Ext.app.ViewModel({formulas:{foo:function(U){return U("x.y")+U("z")}}});var T=Q("foo");expect(T).toEqual(["x.y","z"])});it("should ignore method calls",function(){S=new Ext.app.ViewModel({formulas:{foo:function(U){return U("x.y").substring(1)+U("z").toLowerCase()}}});var T=Q("foo");expect(T).toEqual(["x.y","z"])});it("should recognize data as method parameters",function(){S=new Ext.app.ViewModel({formulas:{foo:function(U){return this.foo(U("x")+U("y.z"))}}});var T=Q("foo");expect(T).toEqual(["x","y.z"])});it("should ignore data used in suffix expression",function(){S=new Ext.app.ViewModel({formulas:{foo:function(U){return this.get.foo(U("x")+U("y.z"))}}});var T=Q("foo");expect(T).toEqual(["x","y.z"])})});describe("formula config objects",function(){it("should recognize property access",function(){S=new Ext.app.ViewModel({formulas:{foo:{get:function(U){return U("x.y")+U("z")}}}});var T=Q("foo");expect(T).toEqual(["x.y","z"])});it("should ignore method calls",function(){S=new Ext.app.ViewModel({formulas:{foo:{get:function(U){return U("x.y").substring(1)+U("z").toLowerCase()}}}});var T=Q("foo");expect(T).toEqual(["x.y","z"])});it("should allow for bind options",function(){S=new Ext.app.ViewModel({data:{x:"XYZ"},formulas:{foo:{bind:{bindTo:"{x}",single:true},get:function(V){return V}}}});var T=Q("foo");expect(T).toEqual([]);K=S.getScheduler();S.notify();expect(K.passes).toBe(1);var U=S.getData();expect(U.foo).toBe("XYZ");S.set("x","ABC");S.notify();expect(K.passes).toBe(2);expect(U.foo).toBe("XYZ")});it("should promote single:true to bind options",function(){S=new Ext.app.ViewModel({data:{x:"XYZ"},formulas:{foo:{bind:"{x}",single:true,get:function(V){return V}}}});var T=Q("foo");expect(T).toEqual([]);K=S.getScheduler();S.notify();expect(K.passes).toBe(1);var U=S.getData();expect(U.foo).toBe("XYZ");S.set("x","ABC");S.notify();expect(K.passes).toBe(2);expect(U.foo).toBe("XYZ")})})});function A(Q){describe(Q?"with session":"without a session",function(){beforeEach(function(){E(Q)});describe("records",function(){var S,T;beforeEach(function(){S=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age","group"]})});afterEach(function(){S=T=null;Ext.undefine("spec.User")});function R(V,U){T=H(S,V,U)}describe("local modifications",function(){it("should publish when setting a record instance",function(){R(1);P("{user}",D);B("user",T);O(T)});it("should publish when binding to a record field",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);O("Foo")});it("should react to a change on the field",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);T.set("name","Bar");G();O("Bar","Foo")});it("should react to multiple field changes",function(){R(1);P("{user.name}",D);P("{user.age}",D);P("{user.group}",D);B("user",T);D.reset();T.set({name:"Foo",age:100,group:"Coders"});G();expect(D.callCount).toBe(3)});it("should not react if the value changes then is reverted to the original value",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);D.reset();T.set("name","Bar");T.set("name","Foo");G();expect(D).not.toHaveBeenCalled()});it("should react if the value changes, notifies, then is reverted to the original value",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);D.reset();T.set("name","Bar");G();O("Bar","Foo");T.set("name","Foo");G();O("Foo","Bar")});it("should react to changes via reject",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);T.set("name","Bar");G();D.reset();T.reject();G();O("Foo","Bar")});it("should publish when setting a new model",function(){R(1);P("{user}",D);B("user",T);var U=new S({id:2});B("user",U);O(U,T)});it("should publish a child field when changing the model",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);var U=new S({id:2,name:"Bar"});B("user",U);O("Bar","Foo")});it("should not publish when setting a new model but the field value remains",function(){R(1,{name:"Foo"});P("{user.name}",D);B("user",T);var U=new S({id:2,name:"Foo"});D.reset();B("user",U);expect(D).not.toHaveBeenCalled()});it("should attach if a record is set as part of a hierarchy",function(){R(1,{name:"Foo"});P("{foo.bar.baz.user.name}",D);B({foo:{bar:{baz:{user:T}}}});D.reset();T.set("name","Bar");G();expect(D).toHaveBeenCalled()})});describe("remote loading",function(){it("should not react when bound and loading",function(){R(1);P("{user}",D);T.load();B("user",T);expect(D).not.toHaveBeenCalled()});it("should react once loading has completed",function(){R(1);P("{user}",D);T.load();B("user",T);M({});expect(D).toHaveBeenCalled()})});describe("links",function(){it("should accept the entityName",function(){P("{theUser}",D);C.linkTo("theUser",{reference:"User",id:18});M({});var U=D.mostRecentCall.args[0];expect(U.$className).toBe("spec.User");expect(U.getId()).toBe(18)});it("should accept the full class name",function(){P("{theUser}",D);C.linkTo("theUser",{reference:"spec.User",id:18});M({});var U=D.mostRecentCall.args[0];expect(U.$className).toBe("spec.User");expect(U.getId()).toBe(18)});it("should accept a model type",function(){P("{theUser}",D);C.linkTo("theUser",{reference:spec.User,id:18});M({});var U=D.mostRecentCall.args[0];expect(U.$className).toBe("spec.User");expect(U.getId()).toBe(18)});it("should accept a model instance but create a copy of the same type/id",function(){var U=new spec.User({id:18});P("{theUser}",D);C.linkTo("theUser",U);M({});var V=D.mostRecentCall.args[0];expect(V.$className).toBe("spec.User");expect(V.getId()).toBe(18);expect(V).not.toBe(U)});it("should create a record with the matching id",function(){P("{theUser}",D);C.linkTo("theUser",{reference:"spec.User",id:18});M({});expect(D.mostRecentCall.args[0].getId()).toBe(18)});it("should request the data from the server",function(){D=spyOn(S.getProxy(),"read");C.linkTo("theUser",{reference:"spec.User",id:18});expect(D.mostRecentCall.args[0].getId()).toBe(18)});it("should not publish until the record returns",function(){P("{theUser}",D);C.linkTo("theUser",{reference:"User",id:18});expect(D).not.toHaveBeenCalled()});it("should be able to change the link at runtime",function(){P("{theUser}",D);C.linkTo("theUser",{reference:"User",id:18});M({});D.reset();C.linkTo("theUser",{reference:"User",id:34});M({});expect(D.mostRecentCall.args[0].getId()).toBe(34)});if(Q){it("should use an existing record in the session and not query the server",function(){var U=spyOn(S.getProxy(),"read");R(22);P("{theUser}",D);C.linkTo("theUser",{reference:"User",id:22});G();expect(D.mostRecentCall.args[0]).toBe(I.getRecord("User",22));expect(U).not.toHaveBeenCalled()});it("should create a non-existent record in the session and load it",function(){expect(I.peekRecord("User",89)).toBeNull();C.linkTo("theUser",{reference:"User",id:89});T=I.getRecord("User",89);expect(T.isLoading()).toBe(true)})}});describe("values via binding",function(){it("should be able to change fields via binding",function(){R(1,{name:"Foo"});var U=C.bind("{user.name}",D);B("user",T);D.reset();U.setValue("Bar");G();O("Bar","Foo")});it("should fail to set values on readonly bindings",function(){var U=C.bind("Hello {user.name}",D);expect(function(){U.setValue("Bar")}).toThrow()})})});describe("stores",function(){var S,T,R;beforeEach(function(){S=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age","group"]});R=new Ext.data.Store({model:S,proxy:{type:"ajax",url:"foo"}})});afterEach(function(){R.destroy();R=S=T=null;Ext.undefine("spec.User")});it("should publish when setting the value",function(){P("{store}",D);B("store",R);O(R,undefined)});it("should not publish if loading when attached",function(){P("{store}",D);R.load();B("store",R);expect(D).not.toHaveBeenCalled()});it("should not publish if the store is loading during a notify",function(){P("{store}",D);C.set("store",R);R.load();G();expect(D).not.toHaveBeenCalled()});it("should publish when the store completes the load",function(){P("{store}",D);R.load();B("store",R);M([]);O(R,undefined)})});describe("associations",function(){describe("many to one",function(){var X,T,V,S,W;beforeEach(function(){S=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"organizationId",reference:"Organization"}]});W=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Post");S=W=X=T=V=null});function R(Z,Y){X=H(S,Z,Y)}function U(Z,Y){T=H(W,Z,Y)}describe("the one",function(){it("should not make a request there is no FK value",function(){var Y=spyOn(S.getProxy(),"read");U(1);P("{post.user}",D);B("post",T);expect(Y).not.toHaveBeenCalled()});it("should load from the server and not publish until the value is retrieved",function(){U(1,{userId:17});P("{post.user}",D);B("post",T);expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});it("should not publish if attached while loading and should publish when the load completes",function(){U(1,{userId:17});P("{post.user}",D);T.getUser();B("post",T);expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});it("should publish immediately if the record has already loaded via the API",function(){U(1,{userId:17});P("{post.user}",D);T.getUser();L({id:17});B("post",T);expect(D).toHaveBeenCalled()});it("should cascade the load if waiting on the one",function(){U(1);P("{post.user}",D);T.load();B("post",T);M({id:1,userId:17});expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});if(Q){it("should use an existing record from the session and not trigger a load",function(){var Y=spyOn(S.getProxy(),"read"),Z=I.createRecord("User",{id:17});U(1,{userId:17});P("{post.user}",D);B("post",T);expect(Y).not.toHaveBeenCalled();expect(D).toHaveBeenCalled();O(Z)});it("should create a record in the session if it does not exist and load it",function(){U(1,{userId:17});P("{post.user}",D);B("post",T);X=T.getUser();expect(X.isLoading()).toBe(true);expect(X).toBe(I.getRecord("User",17))})}else{it("should fire if the record instance is different",function(){U(1,{userId:17});P("{post.user}",D);B("post",T);M({id:17});expect(D).toHaveBeenCalled();D.reset();U(2,{userId:17});B("post",T);M({id:17});expect(D).toHaveBeenCalled()});it("should not fire if the underlying value is the same",function(){U(1,{userId:17});P("{post.user.name}",D);B("post",T);M({id:17,name:"Foo"});expect(D).toHaveBeenCalled();D.reset();U(2,{userId:100});B("post",T);M({id:100,name:"Foo"});expect(D).not.toHaveBeenCalled()})}it("should be able to load multiple levels",function(){Ext.define("spec.Organization",{extend:"Ext.data.Model",fields:["id","name"]});U(1,{userId:17});P("{post.user.organization.name}",D);B("post",T);M({id:17,organizationId:34});expect(D).not.toHaveBeenCalled();M({id:34,name:"Org1"});O("Org1");Ext.undefine("spec.Organization")})});describe("the many",function(){it("should create the store and load it if it doesn't exist",function(){R(1);P("{user.posts}",D);var Y=spyOn(W.getProxy(),"read");B("user",X);expect(Y).toHaveBeenCalled()});it("should not load the store if it's already been loaded",function(){R(1);P("{user.posts}",D);X.posts().load();L([]);var Y=spyOn(W.getProxy(),"read");B("user",X);expect(Y).not.toHaveBeenCalled()});it("should not trigger a load if the store is loading",function(){R(1);P("{user.posts}",D);X.posts().load();var Y=spyOn(W.getProxy(),"read");B("user",X);expect(Y).not.toHaveBeenCalled()});it("should not trigger a load if the store has data in it already",function(){R(1);X.posts().load();L([{id:2000}]);P("{user.posts}",D);var Y=spyOn(W.getProxy(),"read");B("user",X);expect(Y).not.toHaveBeenCalled()});it("should not publish if the attached store is loading, it should wait until the load completes",function(){R(1);P("{user.posts}",D);B("user",X);expect(D).not.toHaveBeenCalled();M([]);expect(D).toHaveBeenCalled()});it("should publish if the store has been loaded before",function(){R(1);P("{user.posts}",D);X.posts().load();L([]);B("user",X);expect(D).toHaveBeenCalled()});it("should publish if the store instance changes",function(){R(1);P("{user.posts}",D);B("user",X);M([]);D.reset();R(2);B("user",X);M([]);expect(D).toHaveBeenCalled()});if(Q){it("should use existing records from the session",function(){var Z=I.getRecord("Post",1),a=I.getRecord("Post",3);L({id:1,userId:1});L({id:3,userId:1});R(1);P("{user.posts}",D);X.posts().load();L([{id:1,userId:1},{id:2,userId:1},{id:3,userId:1}]);B("user",X);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(0)).toBe(Z);expect(Y.getAt(2)).toBe(a)});it("should push any new records into the session",function(){var Z=I.getRecord("Post",1),a=I.getRecord("Post",3);L({id:1,userId:1});L({id:3,userId:1});R(1);P("{user.posts}",D);X.posts().load();L([{id:1,userId:1},{id:2,userId:1},{id:3,userId:1}]);B("user",X);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(1)).toBe(I.getRecord("Post",2))})}})});describe("one to one",function(){var U,T,W,V;beforeEach(function(){U=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"passportId",reference:"Passport",unique:true}]});T=Ext.define("spec.Passport",{extend:"Ext.data.Model",fields:["id","expires",{name:"addressId",reference:"Address",unique:true}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Passport");U=T=W=V=null});function R(Y,X){W=H(U,Y,X)}function S(Y,X){V=H(T,Y,X)}describe("the key holder",function(){it("should not make a request there is no FK value",function(){var X=spyOn(T.getProxy(),"read");R(1);P("{user.passport}",D);B("user",W);expect(X).not.toHaveBeenCalled()});it("should load from the server and not publish until the value is retrieved",function(){R(1,{passportId:17});P("{user.passport}",D);B("user",W);expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});it("should not publish if attached while loading and should publish when the load completes",function(){R(1,{passportId:17});P("{user.passport}",D);W.getPassport();B("user",W);expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});it("should publish immediately if the record has already loaded via the API",function(){R(1,{passportId:17});P("{user.passport}",D);W.getPassport();L({id:17});B("user",W);expect(D).toHaveBeenCalled()});it("should cascade the load if waiting on the one",function(){R(1);P("{user.passport}",D);W.load();B("user",W);M({id:1,passportId:17});expect(D).not.toHaveBeenCalled();M({id:17});expect(D).toHaveBeenCalled()});if(Q){it("should use an existing record from the session and not trigger a load",function(){var X=spyOn(T.getProxy(),"read"),Y=I.createRecord("Passport",{id:17});R(1,{passportId:17});P("{user.passport}",D);B("user",W);expect(X).not.toHaveBeenCalled();expect(D).toHaveBeenCalled();O(Y)});it("should create a record in the session if it does not exist and load it",function(){R(1,{passportId:17});P("{user.passport}",D);B("user",W);V=W.getPassport();expect(V.isLoading()).toBe(true);expect(V).toBe(I.getRecord("Passport",17))})}else{it("should fire if the record instance is different",function(){R(1,{passportId:17});P("{user.passport}",D);B("user",W);M({id:17});expect(D).toHaveBeenCalled();D.reset();R(2,{passportId:17});B("user",W);M({id:17});expect(D).toHaveBeenCalled()});it("should not fire if the underlying value is the same",function(){R(1,{passportId:17});P("{user.passport.expiry}",D);B("user",W);M({id:17,expiry:"2000-01-01"});expect(D).toHaveBeenCalled();D.reset();R(2,{passportId:100});B("user",W);M({id:100,expiry:"2000-01-01"});expect(D).not.toHaveBeenCalled()})}it("should be able to load multiple levels",function(){Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","city"]});R(1,{passportId:17});P("{user.passport.address.city}",D);B("user",W);M({id:17,addressId:34});expect(D).not.toHaveBeenCalled();M({id:34,city:"Sydney"});O("Sydney");Ext.undefine("spec.Address")})});describe("the non-key holder",function(){it("should not publish unless there is an instance set",function(){S(1);P("{passport.user}",D);B("passport",V);expect(D).not.toHaveBeenCalled()});it("should publish if an instance is already set",function(){S(13);R(1,{passportId:13});V.setUser(W);P("{passport.user}",D);B("passport",V);expect(D).toHaveBeenCalled()})})});describe("many to many",function(){var V,U,W,R;beforeEach(function(){V=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name"],manyToMany:"Group"});U=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["id","name"]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Group");V=U=W=R=null});function T(Y,X){W=H(V,Y,X)}function S(Y,X){R=H(U,Y,X)}describe("the left",function(){it("should create the store and load it if it doesn't exist",function(){T(1);P("{user.groups}",D);var X=spyOn(U.getProxy(),"read");B("user",W);expect(X).toHaveBeenCalled()});it("should not load the store if it's already been loaded",function(){T(1);P("{user.groups}",D);W.groups().load();L([]);var X=spyOn(U.getProxy(),"read");B("user",W);expect(X).not.toHaveBeenCalled()});it("should not trigger a load if the store is loading",function(){T(1);P("{user.groups}",D);W.groups().load();var X=spyOn(U.getProxy(),"read");B("user",W);expect(X).not.toHaveBeenCalled()});it("should not trigger a load if the store has data in it already",function(){T(1);W.groups().load();L([{id:3000}]);P("{user.groups}",D);var X=spyOn(U.getProxy(),"read");B("user",W);expect(X).not.toHaveBeenCalled()});it("should not publish if the attached store is loading, it should wait until the load completes",function(){T(1);P("{user.groups}",D);B("user",W);expect(D).not.toHaveBeenCalled();M([]);expect(D).toHaveBeenCalled()});it("should publish if the store has been loaded before",function(){T(1);P("{user.groups}",D);W.groups().load();L([]);B("user",W);expect(D).toHaveBeenCalled()});it("should publish if the store instance changes",function(){T(1);P("{user.groups}",D);B("user",W);M([]);D.reset();T(2);B("user",W);M([]);expect(D).toHaveBeenCalled()});if(Q){it("should use existing records from the session",function(){var Z=I.getRecord("Group",1,false),X=I.getRecord("Group",3,false);T(1);P("{user.groups}",D);W.groups().load();L([{id:1},{id:2},{id:3}]);B("user",W);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(0)).toBe(Z);expect(Y.getAt(2)).toBe(X)});it("should push any new records into the session",function(){var Z=I.getRecord("Group",1,false),X=I.getRecord("Group",3,false);T(1);P("{user.groups}",D);W.groups().load();L([{id:1},{id:2},{id:3}]);B("user",W);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(1)).toBe(I.getRecord("Group",2))})}});describe("the right",function(){it("should create the store and load it if it doesn't exist",function(){S(1);P("{group.users}",D);var X=spyOn(V.getProxy(),"read");B("group",R);expect(X).toHaveBeenCalled()});it("should not load the store if it's already been loaded",function(){S(1);P("{group.users}",D);R.users().load();L([]);var X=spyOn(V.getProxy(),"read");B("group",R);expect(X).not.toHaveBeenCalled()});it("should not trigger a load if the store is loading",function(){S(1);P("{group.users}",D);R.users().load();var X=spyOn(V.getProxy(),"read");B("group",R);expect(X).not.toHaveBeenCalled()});it("should not trigger a load if the store has data in it already",function(){S(1);R.users().load();L([{id:1234}]);P("{group.users}",D);var X=spyOn(V.getProxy(),"read");B("group",R);expect(X).not.toHaveBeenCalled()});it("should not publish if the attached store is loading, it should wait until the load completes",function(){S(1);P("{group.users}",D);B("group",R);expect(D).not.toHaveBeenCalled();M([]);expect(D).toHaveBeenCalled()});it("should publish if the store has been loaded before",function(){S(1);P("{group.users}",D);R.users().load();L([]);B("group",R);expect(D).toHaveBeenCalled()});it("should publish if the store instance changes",function(){S(1);P("{group.users}",D);B("group",R);M([]);D.reset();S(2);B("group",R);M([]);expect(D).toHaveBeenCalled()});if(Q){it("should use existing records from the session",function(){var X=I.getRecord("User",1,false),Z=I.getRecord("User",3,false);S(1);P("{group.users}",D);R.users().load();L([{id:1},{id:2},{id:3}]);B("group",R);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(0)).toBe(X);expect(Y.getAt(2)).toBe(Z)});it("should push any new records into the session",function(){var X=I.getRecord("User",1,false),Z=I.getRecord("User",3,false);S(1);P("{group.users}",D);R.users().load();L([{id:1},{id:2},{id:3}]);B("group",R);expect(D).toHaveBeenCalled();var Y=D.mostRecentCall.args[0];expect(Y.getAt(1)).toBe(I.getRecord("User",2))})}})})})})}A(false);A(true);describe("nesting viewmodels",function(){var Q,T,S,U;function R(W,V){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(Ext.apply({id:W,name:"Name1",age:20,description:"Desc1"},V))})}beforeEach(function(){T=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age","description"]});E(true);S=new Ext.app.ViewModel({id:"subVM",parent:C});U=new Ext.app.ViewModel({id:"grandSubVM",parent:S})});afterEach(function(){U.destroy();S.destroy();Ext.undefine("spec.User");U=S=T=Q=null});it("should inherit data from parent view models",function(){var W=0,V=0;S.bind("{foo.bar}",function(X){W=X;++V});C.set("foo",{bar:42});G();expect(V).toBe(1);expect(W).toBe(42)});it("should inherit data from grandparent view models",function(){var W=0,V=0;U.bind("{foo.bar}",function(X){W=X;++V});C.set("foo",{bar:42});G();expect(V).toBe(1);expect(W).toBe(42)});it("should maintain indirection with multiple view models",function(){var W=0,Y=0,Z=0,V=0,X=0,a=0;C.bind("{foo.bar}",function(b){W=b;++V});S.bind("{foo.bar}",function(b){Y=b;++X});U.bind("{foo.bar}",function(b){Z=b;++a});C.set("foo",{bar:42});G();expect(K.passes).toBe(1);expect(V).toBe(1);expect(W).toBe(42);expect(X).toBe(1);expect(Y).toBe(42);expect(a).toBe(1);expect(Z).toBe(42);S.set("foo",{bar:427});G();expect(K.passes).toBe(2);expect(V).toBe(1);expect(W).toBe(42);expect(X).toBe(2);expect(Y).toBe(427);expect(a).toBe(2);expect(Z).toBe(427);S.set("foo",undefined);G();expect(K.passes).toBe(3);expect(V).toBe(1);expect(W).toBe(42);expect(X).toBe(3);expect(Y).toBe(42);expect(a).toBe(3);expect(Z).toBe(42)});it("should modify parent VM instances",function(){var W=0,Y=0,Z=0,V=0,X=0,a=0;C.bind("{foo.bar}",function(b){W=b;++V});S.bind("{foo.bar}",function(b){Y=b;++X});U.bind("{foo.bar}",function(b){Z=b;++a});C.set("foo",{bar:42});G();expect(K.passes).toBe(1);expect(V).toBe(1);expect(W).toBe(42);expect(X).toBe(1);expect(Y).toBe(42);expect(a).toBe(1);expect(Z).toBe(42);S.set("foo.bar",427);G();expect(K.passes).toBe(2);expect(V).toBe(2);expect(W).toBe(427);expect(X).toBe(2);expect(Y).toBe(427);expect(a).toBe(2);expect(Z).toBe(427)});describe("overwriting values from parent to child",function(){it("should be able to modify a value when the binding is scheduled",function(){C.set("value",1);S.bind("{value}",D);S.set("value",2);C.notify();expect(D.callCount).toBe(1);O(2,undefined)});it("should be able to modify a value when the binding is unscheduled",function(){C.set("value",1);S.bind("{value}",D);C.notify();S.set("value",2);C.notify();expect(D.callCount).toBe(2);O(2,1)})});describe("with formulas",function(){var Y=0,X=0,b=0,V=0,a=0,W=0,Z;beforeEach(function(){C.set({firstName:"Don",lastName:"Griffin",abc:{v:"abc"},xyz:"xyz"});C.setFormulas({foo:function(c){return c("abc.v")+c("xyz")},fullName:{get:function(c){return c("firstName")+" "+c("lastName")},set:function(c){var d=c.split(" ");this.set({firstName:d[0],lastName:d[1]})}}});S.set({xyz:"XYZ"});S.setFormulas({bar:{get:function(c){return c("abc.v")+c("xyz")}},explicit:{get:function(c){return"("+c.foo.v+"/"+c.foo.x+")"},bind:{foo:{v:"{abc.v}",x:"{xyz}"}}}});U.set({abc:{v:"ABC"}});U.setFormulas({baz:function(c){return c("abc.v")+c("xyz")},welcome:function(c){return"Hello "+c("fullName")+"!"}});Z=C.bind("{foo}",function(c){Y=c;++V});S.bind("{bar} - {foo}",function(c){X=c;++a});U.bind("{baz} - {bar} - {foo} - {explicit}",function(c){b=c;++W});G()});it("should bind formulas to values in ancestor viewmodels",function(){expect(K.passes).toBe(1);expect(Y).toBe("abcxyz");expect(X).toBe("abcXYZ - abcxyz");expect(b).toBe("ABCXYZ - abcXYZ - abcxyz - (abc/XYZ)")});it("should not allow setting the value of a formula",function(){expect(function(){Z.setValue(10)}).toThrow()});it("should update when values change in ancestor viewmodels",function(){C.set("abc.v","~abc~");C.set("xyz","~xyz~");G();expect(K.passes).toBe(2);expect(Y).toBe("~abc~~xyz~");expect(X).toBe("~abc~XYZ - ~abc~~xyz~");expect(b).toBe("ABCXYZ - ~abc~XYZ - ~abc~~xyz~ - (~abc~/XYZ)")});it("should react to formula dependencies in base view models",function(){var e,f,d;expect(K.passes).toBe(1);C.bind("{lastName}, {firstName}",function(g){f=g});var c=C.bind("{fullName}",function(g){e=g});U.bind("{welcome}",function(g){d=g});G();expect(K.passes).toBe(2);expect(e).toBe("Don Griffin");expect(f).toBe("Griffin, Don");expect(d).toBe("Hello Don Griffin!");c.setValue("Evan Trimboli");G();expect(K.passes).toBe(3);expect(e).toBe("Evan Trimboli");expect(f).toBe("Trimboli, Evan");expect(d).toBe("Hello Evan Trimboli!")});it("should work with fields on records",function(){S.setFormulas({fromRecord:function(f){return f("rec.fld")}});var c=Ext.define(null,{extend:"Ext.data.Model",fields:["fld"]});Q=new c({fld:42});C.set("rec",Q);var e,d=0;U.bind("The answer is {fromRecord}",function(f){e=f;++d});G();expect(K.passes).toBe(2);expect(d).toBe(1);expect(e).toBe("The answer is 42")});it("should track field changes based on record fields",function(){S.setFormulas({fromRecord:function(e){return e("rec.name")}});C.linkTo("rec",{reference:"User",id:1});var d,c=0;U.bind("Greetings {fromRecord}!",function(e){d=e;++c});R(1,{name:"Don"});G();expect(K.passes).toBe(2);expect(c).toBe(1);expect(d).toBe("Greetings Don!");I.getRecord("User",1).set("name","Evan");G();expect(K.passes).toBe(3);expect(c).toBe(2);expect(d).toBe("Greetings Evan!")})})});describe("validation binding",function(){var R;function Q(S){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(S)})}beforeEach(function(){E(true);R=Ext.define("spec.User",{extend:Ext.data.Model,fields:[{name:"first",type:"string",convert:null},{name:"last",type:"string",convert:null},{name:"email",type:"string",convert:null},{name:"formatField",type:"string",convert:null},{name:"phone",type:"string",convert:null},{name:"color",type:"string",convert:null},{name:"description",type:"string",convert:null},{name:"initial",type:"string",convert:null}],validators:{last:"presence",description:{type:"length",min:10,max:200},color:{type:"inclusion",list:["red","white","blue"]},first:{type:"exclusion",list:["Ed"]},formatField:{type:"format",matcher:/123/},email:"email",phone:{type:"presence",message:"Phone number required"},initial:{type:"length",min:1}},doValidate:function(){}});C.linkTo("theUser",{reference:"User",id:42})});afterEach(function(){Ext.undefine("spec.User")});describe("delivering validation messages",function(){beforeEach(function(){Q({id:42,description:"too short",color:"not a valid color",first:"Ed",formatField:"abc",email:"abc",initial:"X",extraStuff:42})});describe("for invalid fields",function(){var S=Ext.data.validator.Validator.all;it("should report description too short",function(){var T=0,V;C.bind("{theUser.validation.description}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toBe("Length must be between 10 and 200");var U=I.getRecord("User",42);U.set("description","1234567890");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should report missing last name",function(){var V;var T=0;C.bind("{theUser.validation.last}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toBe(S.presence.config.message);var U=I.getRecord("User",42);U.set("last","Spencer");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should have the correct bad format message",function(){var V;var T=0;C.bind("{theUser.validation.formatField}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toEqual(S.format.config.message);var U=I.getRecord("User",42);U.set("formatField","123");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should have the correct non-inclusion message",function(){var V;var T=0;C.bind("{theUser.validation.color}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toEqual(S.inclusion.config.message);var U=I.getRecord("User",42);U.set("color","red");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should have the correct non-exclusion message",function(){var V;var T=0;C.bind("{theUser.validation.first}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toEqual(S.exclusion.config.message);var U=I.getRecord("User",42);U.set("first","Edward");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should have the correct bad email format message",function(){var V;var T=0;C.bind("{theUser.validation.email}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toEqual(S.email.config.message);var U=I.getRecord("User",42);U.set("email","ed@sencha.com");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)});it("should allow user-defined error messages",function(){var V;var T=0;C.bind("{theUser.validation.phone}",function(W){V=W;++T});G();expect(K.passes).toBe(1);expect(T).toBe(1);expect(V).toEqual("Phone number required");var U=I.getRecord("User",42);U.set("phone","555-1212");G();expect(K.passes).toBe(2);expect(T).toBe(2);expect(V).toBe(true)})});describe("for valid fields",function(){it("should report initial as valid",function(){var U;var S=0;C.bind("{theUser.validation.initial}",function(V){U=V;++S});G();expect(K.passes).toBe(1);expect(S).toBe(1);expect(U).toBe(true);var T=I.getRecord("User",42);T.set("initial","");G();expect(K.passes).toBe(2);expect(S).toBe(2);expect(U).toBe("Length must be greater than 1")})})})});describe("multi binding",function(){var Q;beforeEach(function(){E();Q=jasmine.createSpy()});describe("basic static bindings",function(){describe("objects",function(){it("should bind to a simple object",function(){C.bind({aProp:"static"},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({aProp:"static"})});it("should be able to bind to numeric values",function(){C.bind({aProp:1},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({aProp:1})});it("should be able to bind to boolean values",function(){C.bind({aProp:true},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({aProp:true})});it("should allow null values",function(){C.bind({aProp:null},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({aProp:null})})});describe("arrays",function(){it("should bind to a simple array",function(){C.bind(["static1","static2"],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual(["static1","static2"])});it("should be able to bind to numeric values",function(){C.bind([1],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual([1])});it("should be able to bind to boolean values",function(){C.bind([true],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual([true])});it("should be able to bind to null values",function(){C.bind([null],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual([null])})})});describe("basic dynamic bindings",function(){describe("objects",function(){it("should resolve a binding for an object",function(){C.set("aBind","val");C.bind({foo:"{aBind}"},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({foo:"val"})});it("should resolve multiple bindings for an object",function(){C.set("aBind1","val1");C.set("aBind2","val2");C.bind({foo:"{aBind1}",bar:"{aBind2}"},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({foo:"val1",bar:"val2"})})});describe("arrays",function(){it("should resolve a binding for an array",function(){C.set("aBind","val");C.bind(["{aBind}"],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual(["val"])});it("should resolve multiple bindings for an array",function(){C.set("aBind1","val1");C.set("aBind2","val2");C.bind(["{aBind1}","{aBind2}"],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual(["val1","val2"])})})});describe("nested bindings",function(){beforeEach(function(){C.set("aBind1","val1");C.set("aBind2","val2");C.set("aBind3","val3")});it("should resolve a nested object binding",function(){C.bind({bind1:"{aBind1}",nest1:{bind2:"{aBind2}",nest2:{bind3:"{aBind3}"}}},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({bind1:"val1",nest1:{bind2:"val2",nest2:{bind3:"val3"}}})});it("should resolved nested array bindings",function(){C.bind(["{aBind1}",["{aBind2}"],[["{aBind3}"]]],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual(["val1",["val2"],[["val3"]]])});it("should resolve arrays inside objects",function(){C.bind({bind1:["{aBind1}"],nest1:{bind2:["{aBind2}"],nest2:{bind3:["{aBind3}"]}}},Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual({bind1:["val1"],nest1:{bind2:["val2"],nest2:{bind3:["val3"]}}})});it("should resolve objects inside arrays",function(){C.bind([{bind1:"{aBind1}"},[{bind2:"{aBind2}"}],[[{bind3:"{aBind3}"}]]],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual([{bind1:"val1"},[{bind2:"val2"}],[[{bind3:"val3"}]]])})});describe("with formulas",function(){it("should not deliver until formulas is processed",function(){C.setFormulas({b:function(R){return R("a")+"b"},c:function(R){return R("b")+"c"},d:function(R){return R("c")+"d"}});C.set("a","a");C.bind(["{d}","{c}","{b}","{a}"],Q);G();expect(Q).toHaveBeenCalled();expect(Q.mostRecentCall.args[0]).toEqual(["abcd","abc","ab","a"])})});describe("with async data",function(){function R(U,T){S({id:U},T)}function S(U,T){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(U)},T)}beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name"]});Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Post")});it("should not deliver until a record is loaded",function(){C.linkTo("aUser",{reference:"User",id:1});C.bind({theUser:"{aUser}"},Q);G();expect(Q).not.toHaveBeenCalled();R(1);G();expect(Q).toHaveBeenCalled();var T=Q.mostRecentCall.args[0];expect(T.theUser.$className).toBe("spec.User");expect(T.theUser.getId()).toBe(1)});it("should not deliver until all records are loaded",function(){C.linkTo("aUser1",{reference:"User",id:1});C.linkTo("aUser2",{reference:"User",id:2});C.linkTo("aUser3",{reference:"User",id:3});C.bind({user1:"{aUser1}",user2:"{aUser2}",user3:"{aUser3}"},Q);G();expect(Q).not.toHaveBeenCalled();R(2,2);G();expect(Q).not.toHaveBeenCalled();R(3,3);G();expect(Q).not.toHaveBeenCalled();R(1,1);G();expect(Q).toHaveBeenCalled();var T=Q.mostRecentCall.args[0];expect(T.user1.$className).toBe("spec.User");expect(T.user1.getId()).toBe(1);expect(T.user2.$className).toBe("spec.User");expect(T.user2.getId()).toBe(2);expect(T.user3.$className).toBe("spec.User");expect(T.user3.getId()).toBe(3)});it("should not deliver until nested dependencies are loaded",function(){C.linkTo("aUser",{reference:"User",id:1});C.bind({user:"{aUser}",posts:"{aUser.posts}"},Q);G();expect(Q).not.toHaveBeenCalled();R(1);G();expect(Q).not.toHaveBeenCalled();S([{id:1},{id:2}]);G();expect(Q).toHaveBeenCalled();var T=Q.mostRecentCall.args[0];expect(T.user.$className).toBe("spec.User");expect(T.user.getId()).toBe(1);expect(T.posts.isStore).toBe(true);expect(T.posts.getCount()).toBe(2)})})});describe("stores",function(){var R,Q;beforeEach(function(){E();Q=Ext.define("spec.Project",{extend:"Ext.data.Model",fields:["id","name","code"]});R=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"projectId",reference:"Project"}]})});afterEach(function(){Ext.undefine("spec.User");R=null});it("should create a simple store",function(){C.setStores({users:{model:"spec.User"}});G();var S=C.getStore("users");expect(S.isStore).toBe(true);expect(S.getModel()).toBe(R)});it("should bind multiple stores",function(){C.setStores({users1:{model:"spec.User"},users2:{model:"spec.User",filters:[{property:"name",value:"Foo"}]}});G();var T=C.getStore("users1"),S=C.getStore("users2");expect(T.isStore).toBe(true);expect(T.getModel()).toBe(R);expect(S.isStore).toBe(true);expect(S.getModel()).toBe(R);expect(S.getFilters().getCount()).toBe(1)});it("should accept a store instance",function(){var S=new Ext.data.Store({model:"spec.User"});C.setStores({users:S});G();var T=C.getStore("users");expect(T).toBe(S)});it("should not attach the store to the session by default",function(){C.setStores({users:{model:"spec.User"}});G();var S=C.getStore("users");expect(S.getSession()).toBeUndefined()});it("should attach to the session if session: true is specified",function(){C.destroy();E(true);C.setStores({users:{model:"spec.User",session:true}});G();var S=C.getStore("users");expect(S.getSession()).toBe(I)});describe("immediate creation",function(){it("should have a store configuration with no dynamic bindings available before notify",function(){C.setStores({users:{model:"spec.User"}});var S=C.getStore("users");expect(S.isStore).toBe(true);expect(S.getModel()).toBe(R)});it("should have a store instance available before notify",function(){var S=new Ext.data.Store({model:"spec.User"});C.setStores({users:S});expect(C.getStore("users")).toBe(S)})});describe("when destroying the view model",function(){describe("store config",function(){it("should not set autoDestroy on the store",function(){C.setStores({users:{model:"spec.User"}});G();var S=C.getStore("users");expect(S.getAutoDestroy()).toBeUndefined()});it("should destroy the stores when the view model is destroyed",function(){C.setStores({users1:{model:"spec.User"},users2:{model:"spec.User"}});G();var T=C.getStore("users1"),S=C.getStore("users2");spyOn(T,"destroy");spyOn(S,"destroy");C.destroy();expect(T.destroy).toHaveBeenCalled();expect(S.destroy).toHaveBeenCalled()});it("should not destroy if configured with autoDestroy: false",function(){C.setStores({users:{autoDestroy:false,model:"spec.User"}});G();var S=C.getStore("users");spyOn(S,"destroy");C.destroy();expect(S.destroy).not.toHaveBeenCalled()})});describe("store instance",function(){it("should not set autoDestroy on the store",function(){var S=new Ext.data.Store({model:"spec.User"});C.setStores({users:S});G();var T=C.getStore("users");expect(T.getAutoDestroy()).toBeUndefined()});it("should not auto destroy by default",function(){var S=new Ext.data.Store({model:"spec.User"});C.setStores({users:S});G();var T=C.getStore("users");spyOn(T,"destroy");C.destroy();expect(T.destroy).not.toHaveBeenCalled()});it("should auto destroy if configured with autoDestroy: true",function(){var S=new Ext.data.Store({model:"spec.User",autoDestroy:true});C.setStores({users:S});G();var T=C.getStore("users");spyOn(T,"destroy");C.destroy();expect(T.destroy).toHaveBeenCalled()})})});describe("bindings",function(){function S(U,T){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(Ext.apply({id:U},T))})}describe("initial",function(){it("should not create the store until a required binding is present",function(){C.setStores({users:{model:"spec.User",proxy:{type:"ajax",url:"{theUrl}"}}});G();expect(C.getStore("users")).toBeNull();B("theUrl","/foo");var T=C.getStore("users");expect(T.isStore).toBe(true);expect(T.getProxy().getUrl()).toBe("/foo")});it("should wait for all required bindings",function(){C.setStores({users:{model:"spec.User",proxy:{type:"ajax",url:"{theUrl}",extraParams:{id:"{theId}"}}}});G();expect(C.getStore("users")).toBeNull();B("theUrl","/foo");expect(C.getStore("users")).toBeNull();B("theId",12);var T=C.getStore("users");expect(T.isStore).toBe(true);expect(T.getProxy().getUrl()).toBe("/foo");expect(T.getProxy().getExtraParams().id).toBe(12)})});describe("special bindings",function(){it("should be able to bind filters",function(){B("id",1);C.setStores({users:{model:"spec.User",filters:[{property:"someFilter",value:"{id}"}]}});G();expect(C.getStore("users").getFilters().first().getValue()).toBe(1)});it("should be able to bind sorters",function(){B("someField","name");C.setStores({users:{model:"spec.User",sorters:[{property:"{someField}",direction:"ASC"}]}});G();expect(C.getStore("users").getSorters().first().getProperty()).toBe("name")});it("should be able to bind extraParams",function(){B("someParam","val");C.setStores({users:{model:"spec.User",proxy:{type:"ajax",extraParams:{someParam:"{someParam}"}}}});G();expect(C.getStore("users").getProxy().getExtraParams().someParam).toBe("val")})});describe("post-creation bindings",function(){it("should not change the store instance",function(){B("remote",true);C.setStores({users:{model:"spec.User",remoteFilter:"{remote}"}});G();var T=C.getStore("users");expect(T.getRemoteFilter()).toBe(true);B("remote",false);expect(T.getRemoteFilter()).toBe(false);expect(C.getStore("users")).toBe(T)});it("should update the proxy instance",function(){B("theUrl","/urlA");C.setStores({users:{model:"spec.User",proxy:{type:"ajax",url:"{theUrl}"}}});G();var T=C.getStore("users"),U=C.getStore("users").getProxy();expect(U.getUrl()).toBe("/urlA");B("theUrl","/urlB");expect(U.getUrl()).toBe("/urlB");expect(T.getProxy()).toBe(U)});describe("filters",function(){it("should update the existing filter with the new value",function(){B("filterVal",1);C.setStores({users:{model:"spec.User",filters:[{property:"id",value:"{filterVal}"}]}});G();var T=C.getStore("users").getFilters(),U=T.first();expect(T.getCount()).toBe(1);expect(U.getProperty()).toBe("id");expect(U.getValue()).toBe(1);B("filterVal",2);expect(T.getCount()).toBe(1);U=T.first();expect(U.getProperty()).toBe("id");expect(U.getValue()).toBe(2)});it("should maintain existing filters",function(){B("filterVal",1);C.setStores({users:{model:"spec.User",filters:[{property:"id",value:"{filterVal}"},{property:"name",value:"foo"}]}});G();var T=C.getStore("users").getFilters(),U=T.first();expect(T.getCount()).toBe(2);expect(U.getProperty()).toBe("id");expect(U.getValue()).toBe(1);U=T.last();expect(U.getProperty()).toBe("name");expect(U.getValue()).toBe("foo");B("filterVal",2);expect(T.getCount()).toBe(2);U=T.first();expect(U.getProperty()).toBe("id");expect(U.getValue()).toBe(2);U=T.last();expect(U.getProperty()).toBe("name");expect(U.getValue()).toBe("foo")})});describe("sorters",function(){it("should update the existing sorter with the new direction",function(){B("sorterVal","ASC");C.setStores({users:{model:"spec.User",sorters:[{property:"id",direction:"{sorterVal}"}]}});G();var T=C.getStore("users").getSorters(),U=T.first();expect(T.getCount()).toBe(1);expect(U.getProperty()).toBe("id");expect(U.getDirection()).toBe("ASC");B("sorterVal","DESC");expect(T.getCount()).toBe(1);U=T.first();expect(U.getProperty()).toBe("id");expect(U.getDirection()).toBe("DESC")});it("should maintain existing sorters",function(){B("sorterVal","ASC");C.setStores({users:{model:"spec.User",sorters:[{property:"id",direction:"{sorterVal}"},{property:"name",direction:"DESC"}]}});G();var T=C.getStore("users").getSorters(),U=T.first();expect(T.getCount()).toBe(2);expect(U.getProperty()).toBe("id");expect(U.getDirection()).toBe("ASC");U=T.last();expect(U.getProperty()).toBe("name");expect(U.getDirection()).toBe("DESC");B("sorterVal","DESC");expect(T.getCount()).toBe(2);U=T.first();expect(U.getProperty()).toBe("id");expect(U.getDirection()).toBe("DESC");U=T.last();expect(U.getProperty()).toBe("name");expect(U.getDirection()).toBe("DESC")})})})});describe("chained stores",function(){it("should create a chained store",function(){C.setStores({parent:{model:"spec.User"},child:{source:"{parent}"}});G();var S=C.getStore("child");expect(S instanceof Ext.data.ChainedStore).toBe(true)});it("should be able to set the source to an expression",function(){C.setStores({parent:{model:"spec.User"},child:{source:"{parent}"}});G();var T=C.getStore("parent"),S=C.getStore("child");expect(S.getSource()).toBe(T)});it("should bind if the source is a string",function(){C.setStores({parent:{model:"spec.User"},child:"{parent}"});G();var T=C.getStore("parent"),S=C.getStore("child");expect(S.getSource()).toBe(T)});it("should wait until the source binds",function(){C.setStores({parent:{model:"spec.User",remoteSort:"{remoteSort}"},child:{source:"{parent}"}});G();expect(C.getStore("child")).toBeNull();C.set("remoteSort",false);G();var T=C.getStore("parent"),S=C.getStore("child");expect(S.getSource()).toBe(T)})});describe("listeners",function(){var S=Ext.define(null,{extend:"Ext.app.ViewController",someFn:function(){}});it("should resolve listener scope to the view controller",function(){var T=new S();var U=new Ext.Component({controller:T,viewModel:C});C.setView(U);C.setStores({test:{model:"spec.User",listeners:{beforeload:"someFn"}}});G();spyOn(T,"someFn").andReturn();C.getStore("test").load();expect(T.someFn).toHaveBeenCalled();Ext.destroy(U)});it("should resolve listener scope to the component",function(){var T=new Ext.Component({viewModel:C,defaultListenerScope:true,someFn:function(){}});C.setView(T);C.setStores({test:{model:"spec.User",listeners:{beforeload:"someFn"}}});G();spyOn(T,"someFn").andReturn();C.getStore("test").load();expect(T.someFn).toHaveBeenCalled();Ext.destroy(T)});it("should be able to resolve up the hierarchy",function(){var T=new S();var U=new Ext.container.Container({controller:T,items:{xtype:"container",items:{xtype:"container",items:{xtype:"component",itemId:"c",viewModel:C}}}});C.setView(U.down("#c"));C.setStores({test:{model:"spec.User",listeners:{beforeload:"someFn"}}});G();spyOn(T,"someFn").andReturn();C.getStore("test").load();expect(T.someFn).toHaveBeenCalled();Ext.destroy(U)})})});describe("formulas",function(){beforeEach(function(){E()});describe("configuring",function(){var Q;afterEach(function(){Q.destroy()});describe("class definition",function(){describe("sub classing",function(){it("should inherit formulas from the superclass",function(){var R=function(){};var T=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:R}});var S=Ext.define(null,{extend:T});Q=new S();expect(Q.getFormulas().foo).toBe(R)});it("should merge keys",function(){var S=function(){},T=function(){};var U=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:S}});var R=Ext.define(null,{extend:U,formulas:{bar:T}});Q=new R();expect(Q.getFormulas()).toEqual({foo:S,bar:T})});it("should favour the subclass on collision",function(){var S=function(){},T=function(){};var U=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:S}});var R=Ext.define(null,{extend:U,formulas:{foo:T}});Q=new R();expect(Q.getFormulas().foo).toBe(T)});it("should not attempt to merge a function with an object definition",function(){var R=function(){};var T=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:{get:function(){},set:function(){}}}});var S=Ext.define(null,{extend:T,formulas:{foo:R}});Q=new S();expect(Q.getFormulas().foo).toBe(R)})});describe("mixin",function(){afterEach(function(){Ext.undefine("spec.Mixin")});it("should copy formulas from the mixin",function(){var R=function(){};var T=Ext.define("spec.Mixin",{config:{formulas:{foo:R}}});var S=Ext.define(null,{extend:"Ext.app.ViewModel",mixins:[T]});Q=new S();expect(Q.getFormulas().foo).toBe(R)});it("should merge keys",function(){var S=function(){},T=function(){};var U=Ext.define("spec.Mixin",{config:{formulas:{foo:S}}});var R=Ext.define(null,{extend:"Ext.app.ViewModel",mixins:[U],formulas:{bar:T}});Q=new R();expect(Q.getFormulas()).toEqual({foo:S,bar:T})});it("should favour the class on collision",function(){var S=function(){},T=function(){};var U=Ext.define("spec.Mixin",{config:{formulas:{foo:S}}});var R=Ext.define(null,{extend:"Ext.app.ViewModel",mixins:[U],formulas:{foo:T}});Q=new R();expect(Q.getFormulas().foo).toBe(T)});it("should not attempt to merge a function with an object definition",function(){var R=function(){};var T=Ext.define("spec.Mixin",{config:{formulas:{foo:{get:function(){},set:function(){}}}}});var S=Ext.define(null,{extend:"Ext.app.ViewModel",mixins:[T],formulas:{foo:R}});Q=new S();expect(Q.getFormulas().foo).toBe(R)})})});describe("instance",function(){it("should inherit formulas from the class",function(){var R=function(){};var S=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:R}});Q=new S();expect(Q.getFormulas().foo).toBe(R)});it("should merge keys",function(){var R=function(){},S=function(){};var T=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:R}});Q=new T({formulas:{bar:S}});expect(Q.getFormulas()).toEqual({foo:R,bar:S})});it("should favour the instance on collision",function(){var R=function(){},S=function(){};var T=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:R}});Q=new T({formulas:{foo:S}});expect(Q.getFormulas().foo).toBe(S)});it("should not attempt to merge a function with an object definition",function(){var R=function(){};var S=Ext.define(null,{extend:"Ext.app.ViewModel",formulas:{foo:{get:function(){},set:function(){}}}});Q=new S({formulas:{foo:R}});expect(Q.getFormulas().foo).toBe(R)})})});it("should deliver a value if it's static",function(){C.bind("{formula1}",D);C.setFormulas({formula1:function(){return 1}});G();expect(D).toHaveBeenCalled();expect(D.mostRecentCall.args[0]).toBe(1)});it("should wait until values are delivered before evaluating",function(){C.bind("{f1}",D);C.setFormulas({f1:function(Q){return Q("foo")+Q("bar")}});G();expect(D).not.toHaveBeenCalled();B("foo",100);expect(D).not.toHaveBeenCalled();B("bar",300);expect(D).toHaveBeenCalled();expect(D.mostRecentCall.args[0]).toBe(400)});it("should allow formulas to depend on other formulas",function(){C.bind("{f1}",D);C.setFormulas({f1:function(Q){return Q("f2")+1},f2:function(Q){return Q("f3")+1},f3:function(Q){return Q("value")+1}});B("value",100);expect(D).toHaveBeenCalled();expect(D.mostRecentCall.args[0]).toBe(103)})});describe("the scheduler",function(){it("should create a scheduler if there is no parent",function(){E();expect(C.getScheduler() instanceof Ext.util.Scheduler).toBe(true)});it("should use the scheduler of the parent VM",function(){E();var Q=new Ext.app.ViewModel({parent:C});expect(Q.getScheduler()).toBe(C.getScheduler());Q.destroy();Q=null})})});